#!/bin/bash
#@+leo-ver=5-thin
#@+node:jkuan.20140101001347.1707: * @file bin/n7
#@@first
#
# N7 - Ad Hoc Task Automation and Orchestration in Bash.
#

#set -x

set -e

#@+others
#@+node:jkuan.20140101001347.1710: ** configure logging and other core utility functions
declare -rA N7_LOG_LEVELS=([DEBUG]=-1 [INFO]=0 [WARNING]=1 [ERROR]=2 [FATAL]=3 [QUIET]=99)
declare -i N7_VERBOSE=${N7_LOG_LEVELS[INFO]}

N7::log() {
    local level=${2:-"INFO"}; 
    local -i ilevel=${N7_LOG_LEVELS[$level]?:"Invalid log level: $level"}
    if [ "$ilevel" -ge "$N7_VERBOSE" ]; then
        printf "%(%Y-%m-%dT%T%z)T|N7|$USER|$level|$1\n" -1
    fi
}
N7::die() { N7::log "$1" ${2:-ERROR} >&2; exit 1; }
#@+node:jkuan.20140101001347.1711: ** parse command-line options
N7::usage() {
  echo "$(echo "\
    Usage: $(basename "$0") [options] [arg1 arg2 ...]

    Each argument, if provided, will be wrapped and run in a N7 *remote* task.
    However, If the -s option is provided then each argument will be passed to
    the N7 script as command line arguments.
        
    Options:
      -h          Show this help. 

      -m HOSTS    A list of comma separated hosts. Hosts will be read from
                  STDIN(one host per line) if the -m option is not specified.

      -s FILE     Source and execute tasks in FILE after running the commands
                  specified on the command line.

      --          Mark the end of command-line options. The rest of command line
                  arguments won't be parsed as options to n7. This might be
                  useful for passing options specific to a n7 script.

      -v LEVEL    Set the verbose level. Defaults to INFO.
                  Levels available: $(
                       for k in ${!N7_LOG_LEVELS[*]}; do
                           echo ${N7_LOG_LEVELS[$k]} $k
                       done | sort -n | cut -d' ' -f2 | xargs
                  )

      -o          Show task stdout at the end of a task from each host.
                  Local and command-line task outputs are always shown unless you
                  redirect them in the task.

      -k          Keep the run directory after execution. The run directory, which
                  is unique to each n7 invocation, stores the runtime files such as
                  stdout and stderr files from each remote host, etc.

      -p COUNT    Limit the number of parallel SSH processes to COUNT at a time.

" | sed -e 's/    //')"
}

while getopts ':hs:m:v:okp:-' option; do
    case $option in
        s) N7_SCRIPT=$OPTARG ;;
        m) N7_HOSTS=$(tr , ' ' <<<"$OPTARG") ;;
        v) N7_VERBOSE=${N7_LOG_LEVELS[$OPTARG]?:"Invalid log level: $OPTARG"} ;;
        o) N7_TASK_SHOW_STDOUT=1 ;;
        k) N7_KEEP_RUN_DIR=1 ;;
        p) declare -r N7_SSH_COUNT=$OPTARG 
           [ "$N7_SSH_COUNT" -gt 0 ] ||
               N7::die "Invalid value($N7_SSH_COUNT) for the -p option!"
            ;;
        h) N7::usage; exit ;;
        -) break ;;
        :) N7::die "Missing option argument for -$OPTARG" ;;
        \?) N7::die "Unknown option: -$OPTARG" ;;
    esac
done
unset option
shift $(($OPTIND - 1))
#@+node:jkuan.20140101001347.1712: ** define helper functions
N7::close_ssh_pipes() {
    local fd pid_pgid host
    for fd in ${N7_SSH_PIPE_FDs[*]}; do
        eval "exec $fd>&-"
    done

    # kill ssh processes
    [ -r "$N7_SSH_PIDs" ] && {
        kill $(<"$N7_SSH_PIDs") >/dev/null 2>&1
        rm "$N7_SSH_PIDs"
    }

    # kill -9 each of the whole process groups that's reading the ssh pipes.
    for pid_pgid in $(ps x -opid,pgid | awk 'NR==1 {next}; {printf("%d,%d\n", $1, $2)}'); do
        if [[ " ${N7_SSH_PPIDs[*]} " =~ " ${pid_pgid%,*} " ]]; then
            kill -9 -- -${pid_pgid#*,} >/dev/null 2>&1
        fi
    done

    for host in $N7_HOSTS; do
        rm -f "$(N7::ssh_read_pipe $host)"
    done
}


N7::cleanup() {
    # this is to silence bash from reporting to stderr that a
    # child process was killed with SIGKILL.
    exec 2>>"$N7_INTERNAL_ERR_FILE"
    
    N7::close_ssh_pipes
    rm -f "$N7_EHOSTS_FILE"
    if [ ! "$N7_KEEP_RUN_DIR" ]; then
        rm -rf "$N7_RUN_DIR"
    fi
}

N7::ssh_read_pipe() { echo "$N7_RUN_DIR/$1.pipe_r"; }
N7::ssh_out_file() { echo "$N7_RUN_DIR/$1.out"; }
N7::ssh_err_file() { echo "$N7_RUN_DIR/$1.err"; }
N7::ssh_host_from_out_file() { echo $(basename "${1%.out}"); }
N7::send_cmd() { printf "%s\n" "$1" >"$(N7::ssh_read_pipe ${2:?'Empty host!'})"; }

N7::send_eot_line() {
    local changed_f=$(N7::remote::tasks::change_file)

    # the line is: <eot_hash> <hostname> <task_index|-1> <exit_status|$?> <changed|->
    local line="$N7_EOT $1 ${N7_TASK_IDX:--1} ${2:-\$N7_RC} \
               \$([ -e $(N7::q "$changed_f") ] && echo changed || echo -)"

    N7::send_cmd "N7_RC=\$?; echo ; echo $line; echo >&2; echo $line >&2" ${1:?'Empty host!'}
    #
    # NOTE: we always output a newline before sending the EOT line so
    #       that the EOT line will always be on its own line.
}


N7::is_num() { [ "$1" ] && printf "%.0f" "$1" >/dev/null 2>&1; }
N7::is_int() { [ "$1" ] && printf "%d" "$1" >/dev/null 2>&1; }
N7::mktemp() {
    tmpdir=$N7_TMP_DIR mktemp -t .tmp.XXXXXXXXXXX ||
        N7::die "Failed creating a temporary file!"
}
N7::ssh_ehosts() {
    if [ -r "$N7_EHOSTS_FILE" ]; then
        N7_EHOSTS=$(<"$N7_EHOSTS_FILE") 2>/dev/null
        rm -f "$N7_EHOSTS_FILE"
    fi
    echo $N7_EHOSTS
}



# N7::load_tasks
#
# Load up N7_TASKS with task names in the order they are defined in N7_SCRIPT.
#
N7::load_tasks() {
    # Add built-in tasks
    N7_TASKS+=(${N7_BUILTIN_TASKS[*]})

    # Add command-line tasks
    N7_TASKS+=($(declare -f | grep "^\.N7::cli_task::" | cut -d' ' -f1 | sort -t: -nk5))
    #FIXME: use N7_CLI_TASK_PREFIX, but need to escape regex chars...

    shopt -s extdebug
    N7_TASKS+=($(
        for f in $(declare -f | grep '^\.' | cut -d' ' -f1); do
            line=$(declare -F $f)
            p=${line#* }; p=${p#* }
            if [ "$p" = "$N7_SCRIPT" ]; then printf "%s\n" "$line"; fi
        done | sort -nk2 | cut -d' ' -f1)
    )
    shopt -u extdebug
    if [ ${#N7_TASKS[*]} -le ${#N7_BUILTIN_TASKS[*]} ]; then
        N7::log "No tasks are defined!" WARNING
    fi
}


# N7::parse_task_opts <task_defn>
#
# Take a function definition, parse all leading null commands(:) of the form:
#
#     ': name1=value1'
#     ': name2=value2'
# 
# until the first non-null command, which marks the end of the task option section.
#
# Output the right hand side of an associative array assignment of this form:
#
#     '(
#      [name1]=value1
#      [name2]=value2
#        ...
#      )'
#
N7::parse_task_opts() {
    local section=$(awk '/^ *: /, $0 ~ "^ *[^#]" && $0 !~ "^ *: " {print}' <<<"$(declare -f $1)")
    echo "("
    echo "$section" | sed '$d
      s/^ *:  *//g 
      s/\([^ ]\)/\[\1/ 
      s/=/\]=/
      s/;$//
    '
    echo ")"
}

# Usage: N7::get_task_opt <task_idx> <opt_name>
N7::get_task_opt() {
    local task_opt="N7_TASK_OPTS_$1[$2]"
    printf "%s\n" "${!task_opt}"  
}

# N7::load_task_opts <all task definitions...>
#
# Dynamically assign a global array variable, N7_TASK_OPTS_{n}.
#
# So as an example, for the first task(task 0) you have N7_TASK_OPTS_0.
# The options in such array can be obtained via the `N7::get_task_opt' function.
#
N7::load_task_opts() {
    local task_idx=-1 task task_opts name val
    while [[ $# > 0 ]]; do
        name=N7_TASK_OPTS_$((++task_idx))
        task=$1; shift
        task_opts=$(N7::parse_task_opts "$task")

        #HACK: if there's a syntax error with the array assignment then this will exit 1.
        set -e; source <(echo "declare -gA $name; $name=$task_opts"); set +e

        # check if each option name is valid
        val=($(eval echo '${!'$name'[*]}'))
        for name in ${N7_TASK_OPT_NAMES[*]}; do val=(${val[*]/#$name}); done
        if [ "$(echo ${val[*]})" ]; then   #FIXME: option value might conflict with echo's options
            N7::die "Invalid task options(${val[*]}) in task #$task_idx"
        fi
        
        # validate the TIMEOUT value
        val=$(N7::get_task_opt $task_idx TIMEOUT)
        [ ! "$val" ] || [ "$val" -gt 0 ] || N7::die "Invalid timeout(\`$val') for task #$task_idx!"

        # set NAME to function name if it's not specified.
        if [ ! "$(eval echo \${N7_TASK_OPTS_$task_idx[NAME]})" ]; then
            eval N7_TASK_OPTS_$task_idx[NAME]=$task
        fi

        # deal with LOCAL and REMOTE
        local localremote=$(echo "$task_opts" | grep -P '^\[LOCAL|REMOTE\]=' | tail -n1)
        val=N7_TASK_OPTS_$task_idx
        if [[ ! $localremote ]]; then
            eval $val[$N7_DEFAULT_TASK_TYPE]=1
        elif [[ $localremote  == \[LOCAL\]=* ]]; then
            eval unset $val[REMOTE]
        elif [[ $localremote  == \[REMOTE\]=* ]]; then
            eval unset $val[LOCAL]
        fi
    done
}


# N7::wait_for_tasks_on_hosts <task_idx> [host1 host2 ...]
#
# Periodically look at the last line of each host out-file, expecting the EOT marker.
#
# If the EOT line is found at the end within task timeout, then it means the last
# task has finished. Otherwise, the task has been timed out.
#
# Output the EOT lines. For timed out hosts, the rc field of the EOT line will be
# set to $N7_ERRNO_TIMEOUT.
#
N7::wait_for_task_on_hosts() {
    local task_idx=$1; shift
    local timeout=$(N7::get_task_opt $task_idx TIMEOUT)
    local out_files=$(for h in $*; do N7::ssh_out_file $h; done)
    local eot_lines

    timeout=${timeout:-$N7_TASK_TIMEOUT}
    SECONDS=0
    while (( SECONDS < timeout )); do
        sleep 0.01
        eot_lines=$(IFS=$'\n'; tail -v -n1 $out_files | grep -aPB1 "^$N7_EOT [^ ]+ \b$task_idx\b \d+")
        # Note: with tail's '==> path <==' headers.

        out_files=$(
            diff <(echo "$eot_lines" | grep "^==>" | cut -d' ' -f2 | sort) \
                 <(echo "$out_files" | sort) | grep '^>' | cut -d' ' -f2
        )
        [ "$eot_lines" ] && grep "^$N7_EOT" <<<"$eot_lines"
        [ ! "$out_files" ] && return # ie, all out files have the EOT at the end.

    done
    local path oIFS=$IFS
    IFS=$'\n'
    for path in $out_files; do
        echo "$N7_EOT $(N7::ssh_host_from_out_file "$path") $task_idx $N7_ERRNO_TIMEOUT"
    done
    IFS=$oIFS
}

# N7::wait_for_task <task_idx> [host1 host2 ...]
#
# Wait for task to finish running until a timeout on each host.
# Outputs a string of hosts that N7 will be using for running the next task.
#
N7::wait_for_task() {
    local task_idx=$1; shift
    local hosts=$*
    local host rc

    # wait for the EOT marker at the end in each host's out file
    while read _ host _ rc _; do

        if [ "$rc" != 0 ]; then

            # remove timed out host so that it won't block the next task
            if [ "$rc" = $N7_ERRNO_TIMEOUT ]; then
                hosts=$(echo ${hosts/$host})

            # remove failed host if the task has no IGNORE_STATUS set
            elif [ ! "$(N7::get_task_opt $task_idx IGNORE_STATUS)" ]; then
                hosts=$(echo ${hosts/$host})
            fi
        fi
        #NOTE: if a task is timed out but has IGNORE_STATUS set, and
        #  is actually still executing, it will block the tasks after
        #  it(because all tasks for a host share one ssh pipe), thus
        #  its following tasks are likely also going to be timed out.
    done < <(N7::wait_for_task_on_hosts $task_idx $hosts)
    echo $hosts
}


# N7::ssh_connect [host1 host2 ...]
#
# Establish ssh connections to remote hosts and setup named pipes and
# I/O redirects for N7 to communicate with the ssh processes and to
# recieve task outputs.
#
N7::ssh_connect() {
    local host ssh_pipe ssh_out ssh_err fd
    for host in $*; do
        ssh_pipe=$(N7::ssh_read_pipe $host)
        if [ -e "$ssh_pipe" ]; then
            continue
        fi
        ssh_out=$(N7::ssh_out_file $host)
        ssh_err=$(N7::ssh_err_file $host)
        mkfifo "$ssh_pipe" || N7::die "Failed making named pipes for ssh!"
        set -m  # temporarily enable job control to create the following
        (       # subshell in its own process group.
          $N7_SSH_CMD $host 'exec -l /bin/bash' <"$ssh_pipe" >"$ssh_out" 2>"$ssh_err" &
          ssh_pid=$!
          echo $ssh_pid >>"$N7_SSH_PIDs"
          wait $ssh_pid
          if [ $? -gt 0 -a $? -lt 128 ]; then
              N7::log "$(echo "SSH connection to $host disconnected!"; cat "$ssh_err")"
          fi

          # remove the ssh pid from the ssh pid file
          sed -i '' -e "/^$ssh_pid\$/d" "$N7_SSH_PIDs" >/dev/null 2>&1

          # make any further writes to the pipe fail without blocking,
          # then read from the pipe to unblock the process that had written
          # to it before the chmod.
          chmod a-w "$ssh_pipe" &&
          while true; do cat "$ssh_pipe" >/dev/null; done #FIXME: don't discard the data read?
        ) 2>>"$N7_INTERNAL_ERR_FILE" & set +m
        N7_SSH_PPIDs+=($!)

        # this is just to keep the pipe from being closed when its
        # write end closes.
        exec {fd}>"$ssh_pipe" || N7::die "Failed FD creations and redirections"
        N7_SSH_PIPE_FDs+=($fd)
    done
}

# N7::show_task_outputs <task_idx>
#
# Print the stdout of the task specified by the task index if the -o command-line
# option is set. Stdouts of local and command-line tasks are always shown.
#
N7::show_task_outputs() {
    local task_idx=$1; shift
    local task_name=${N7_TASKS[$task_idx]}
    [[ $N7_TASK_SHOW_STDOUT || ${task_name/#$N7_CLI_TASK_PREFIX} != $task_name  ]]
    local show_output=$?

    local host from_line out_file
    for host in $*; do
        if [ "$show_output" = 0 ]; then
            out_file=$(N7::ssh_out_file $host)
            from_line=$(grep -an "^$N7_EOT $host $((task_idx - 1)) " "$out_file" |
                    tail -n1 | cut -d: -f1)
            let ++from_line
            tail -n+$from_line "$out_file"
            #
            #NOTE: when outputing stdout, we are not removing the EOT line nor the
            #      empty line before it because even though those are not send by
            #      the user, removing them risk removing user output in the case
            #      of timeout.
            #
            # The N7::local::tasks::get_stdout() won't output the EOT line, and
            # using $(...) with the function usually gives the desired result
            # because bash always remove trailing newlines from a command
            # substitution.
        else
            N7::log "$host rc=$rc"
        fi
    done
}

# N7::run_tasks <"task_name1 task_name2 ..."> ["host1 host2 ..."]
# 
# Execute the bash functions(tasks) named on all the hosts specified.
# Each task will be run on all hosts, and a task must finish its execution on all hosts
# before the next will be run. If a task execution fails or timed out on a host then
# that host will be removed from execution of any further tasks unless the task has
# its IGNORE_STATUS option set and is not timed out.
#
# Moreover, the following environment variables will be available to all tasks:
#
#   N7_TASK_IDX - The index number(0-based) of the current task.
#   N7_EHOSTS   - "The effective hosts". A space separated list of hosts that the
#                 current task is going through.
#   N7_HOST     - The host on which the current task is running.
#
N7::run_tasks() {
    N7_EHOSTS=$(echo $2)

    # export it so this will be available to local tasks.
    local N7_TASK_IDX=-1; export N7_TASK_IDX

    set -- $1

    N7::ssh_connect $N7_EHOSTS

    local host task rc no_subshell sudo hosts

    while [[ $# > 0 && $N7_EHOSTS ]]; do
        task=$1; shift
        let ++N7_TASK_IDX
        no_subshell=$(N7::get_task_opt $N7_TASK_IDX NO_SUBSHELL)

        N7::log "Running Task #$N7_TASK_IDX: $(N7::get_task_opt $N7_TASK_IDX NAME) ..."

        # handle local task, which has no timeout control.
        if [ "$(N7::get_task_opt $N7_TASK_IDX LOCAL)" ]; then
            export N7_HOST=localhost;

            if [ "$no_subshell" ]; then $task; else ($task); fi; rc=$?
            N7::log "localhost rc=$rc"

            if [ "$rc" != 0 -a ! "$(N7::get_task_opt $N7_TASK_IDX IGNORE_STATUS)" ]; then
                N7::die "Error running local task #$N7_TASK_IDX: $(N7::get_task_opt $N7_TASK_IDX NAME)"
            fi

            # the local task might invoke a function that changes N7_EHOSTS in a subshell
            # this updates the global N7_EHOSTS var from N7_EHOSTS_FILE.
            N7::ssh_ehosts >/dev/null

            # We also send an EOT line to each remote host at the end of a local task.
            # This is to make extracting stdout or stderr of a remote task easier.
            for host in $N7_EHOSTS; do N7::send_eot_line $host $rc; done

            continue
        fi

        # send the remote task to each host
        for host in $N7_EHOSTS; do
            N7::run_pre_post_task_function pre $task $host
            N7::send_cmd " \
                export N7_TASK_IDX=$N7_TASK_IDX \
                       N7_EHOSTS=\$(echo $N7_EHOSTS) \
                       N7_HOST=$(N7::q "$host") \
                " $host
            [ "$no_subshell" ] || N7::send_cmd '('             $host
                                  N7::send_cmd $task           $host
            [ "$no_subshell" ] || N7::send_cmd ') </dev/null'  $host
            N7::send_eot_line $host
            N7::run_pre_post_task_function post $task $host
        done

        hosts=$(N7::wait_for_task $N7_TASK_IDX $N7_EHOSTS)
        N7::show_task_outputs $N7_TASK_IDX $N7_EHOSTS
        N7_EHOSTS=$hosts
    done
}

# 
# N7::run_pre_post_task_function <pre|post> <task_name> <hostname>
#
# Every remote task is allowed to have a pre-task function and a
# post-task function. These functions will be executed locally before
# and after the remote task respectively.
#
# Such function will be passed the hostname, on which the remote
# task will be or has been run, as its first argument.
#
# One use of such function is to obtain, via the N7::local::tasks:get_stdout
# function, the stdout of the last remote task run on the same host, and then
# do something immediately or set a flag for the next task to act accordingly.
#
N7::run_pre_post_task_function() {
    local fname=$0:$1
    local host=$2
    if declare -f $fname; then
 #FIXME: need to make sure the function is defined in the same source file, 
 #       in which the remote task is defined.
        $fname $host
    fi
}



#@+node:jkuan.20140105132438.2228: ** define N7 initialization tasks

# This is the very first task that gets run by N7 to bootstrap remote
# tasks, and environment variables.
#
.N7::init_local() { : LOCAL=1; set -e
    # define remote tasks on remote hosts
    local task i=0
    for task in ${N7_TASKS[*]}; do
        if [ "$(N7::get_task_opt $i REMOTE)" ]; then
            N7::local::commands::send_funcs $task
        fi
        i=$((++i))
    done
    N7::local::commands::send_env  \
        N7_SUDO=$(N7::q "$N7_SUDO") \
        N7_REMOTE_RUN_DIR=$(N7::q "$N7_REMOTE_RUN_DIR") \
        N7_REMOTE_TMP_DIR=$(N7::q "$N7_REMOTE_TMP_DIR") \
        N7_ANSIBLE_OUT=$(N7::q "$N7_ANSIBLE_OUT")
}

# This is the first remote task run by N7 to setup remote N7 built-ins
#
.N7::init_remote() {
    : REMOTE=1
    : NO_SUBSHELL=1

    # create N7 runtime directories
    mkdir -p "$N7_REMOTE_RUN_DIR" "$N7_REMOTE_TMP_DIR"
}

.N7::define_builtins() {
    : REMOTE=1
    : NO_SUBSHELL=1

    N7::q() { printf "%q\n" "$*"; }
    N7::qm() {
        local result=$(printf "%q " "$@")
        printf "${result% }\n"
    }
    N7::get_sudo() {
        local sudo=${1:-$N7_SUDO}
        if [ "$sudo" = 1 ]; then echo "$N7_SUDO"; else echo "$sudo"; fi
    }

    #@+<< remote built-ins >>
    #@+node:jkuan.20140101001347.1713: *3* << remote built-ins >>
    # Functions under the N7::remote "namespace can be used both remotely and locally.

    #@+others
    #@+node:jkuan.20140101001347.1726: *4* N7::remote::files::file
    #
    # Set file attributes. Options are:
    #
    #   owner  - owner name.
    #   group  - group name.
    #   mode   - file permission mode; only numeric octal digits allowed.
    #
    # Environment vars that affect the command:
    #
    #   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
    #            value to use as the command to sudo.
    #
    # This function can be use both remotely and locally.
    #
    N7::remote::files::file() {
        local path=$(N7::q "$1")
        declare -A params=()
        local nv
        for nv in "$@"; do
            [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
        done
        ${sudo:+$(N7::get_sudo "$sudo")} /bin/bash -s -- <<EOF
            owner=$(N7::q "${params[owner]}")
            group=$(N7::q "${params[group]}")
            mode=$(N7::q "${params[mode]}")
            mode=\${mode:-0\$(printf %o \$((0666 - \$(umask))))}
            rt=0
            read u g m < <(stat -c "%U %G %a" $path)
            if [[ \$owner ]]; then [[ \$u == \$owner ]] || { chown \$owner $path; rt=\$((\$? | rt)); }; fi
            if [[ \$group ]]; then [[ \$g == \$group ]] || { chgrp \$group $path; rt=\$((\$? | rt)); }; fi
            if [[ \$mode  ]]; then [[ \$m == \$mode  ]] || { chmod \$mode  $path; rt=\$((\$? | rt)); }; fi
            exit \$rt
    #@@raw
EOF
    #@@end_raw
    }
    #@+node:jkuan.20140101001347.1727: *4* N7::remote::tasks::change_file
    N7::remote::tasks::change_file() {
        local task_idx=${1:-$N7_TASK_IDX}
        if [ "$N7_HOST" != "localhost" ]; then
            echo "$N7_REMOTE_RUN_DIR/task_$task_idx.change"
        else
            echo "$N7_RUN_DIR/task_$task_idx.change"
        fi
    }
    #@+node:jkuan.20140101001347.1728: *4* N7::remote::tasks::touch_change
    N7::remote::tasks::touch_change() {
        local change_file=$(N7::remote::tasks::change_file)
        [ -e "$change_file" ] || touch "$change_file"
    }
    #@+node:jkuan.20140101001347.1729: *4* N7::remote::tasks::changed
    N7::remote::tasks::changed() {
        [ -e "$(N7::remote::tasks::change_file $1)" ]
    }
    #@+node:jkuan.20140109170044.1919: *4* N7::remote::ansible::check_status
    N7::remote::ansible::check_status() {
    #@@raw
     python -c '
import sys, json
#FIXME: handle single line name=value pairs
with open(sys.argv[1]) as f:
    data = json.load(f)
if "failed" in data:
    sys.exit(1)
'    "$N7_ANSIBLE_OUT"
    #@@end_raw
    }
    #@-others
    #@-<< remote built-ins >>

}
#@+node:jkuan.20140105132438.2229: ** N7 built-in functions
#@-others

#@+<< globals >>
#@+node:jkuan.20140101001347.1708: ** << globals >>
if [ "$N7_SCRIPT" ]; then
    N7_SCRIPT_ARGS=("$@")
fi

# Read from stdin a list of hostnames, one per line, to ssh into.
if [ ! "$N7_HOSTS" ]; then N7_HOSTS=$(</dev/stdin); fi

# De-duplicate the hostnames
N7_HOSTS=$(echo $N7_HOSTS | tr ' ' '\n' | sort | uniq)
declare -r N7_HOSTS
#FIXME: should use host:port combination rather than just host

# The "effective" host list. It gets updated by `run_tasks()' while N7_HOSTS doesn't.
N7_EHOSTS=

# Task definitions are just bash functions defined in a script.
# Any function named with a `.' prefix is a task.
declare -r N7_SCRIPT

# Function name prefix for command-line tasks.
declare -r N7_CLI_TASK_PREFIX=.N7::cli_task::

# If command line commands are provided then wrap the commands
# in N7 tasks.
if [ ! "$N7_SCRIPT" ]; then
    i=0
    for cmd in "$@"; do
        eval "${N7_CLI_TASK_PREFIX}$i() { : REMOTE=1
            $cmd
        }"
        let ++i
    done
    unset cmd i
fi

# Task names in execution order.
N7_TASKS=()

# These are N7 built-in tasks used to bootstrap N7.
N7_BUILTIN_TASKS=(.N7::init_local .N7::init_remote .N7::define_builtins)
declare -r N7_BUILTIN_TASKS

# In case no LOCAL nor REMOTE task option is set for a task, this will
# be the default.
N7_DEFAULT_TASK_TYPE=${N7_DEFAULT_TASK_TYPE:-LOCAL}


# Each task can optionally have leading null commands that specifies task specific
# options. See the `N7::load_task_opts' function for the exact format.
# Known task options are:
N7_TASK_OPT_NAMES=(
  DESCRIPTION     # describe what the task does.
  TIMEOUT         # timeout in seconds for the remote task.
  NO_SUBSHELL     # set it to run the task directly in the N7 login shell.

  LOCAL           # set it to run the task locally.
  REMOTE          # set it to run the task remotely.

  #Note: If both LOCAL and REMOTE are set then the which ever is set
  #      later overrides the former; if neither LOCAL nor REMOTE is set
  #      then, the task is of the $N7_DEFAULT_TASK_TYPE, which defaults to
  #      LOCAL.

  IGNORE_STATUS   # set it to run the remaining tasks even if the task exited
                  # with a non-zero exit status. 
)
declare -r N7_TASK_OPT_NAMES

N7_TASK_TIMEOUT=${N7_TASK_TIMEOUT:-60}    # default task timeout, in seconds.
N7_ERRNO_TIMEOUT=999  # a task exits with this exit code if it's timed out.
declare -r N7_ERRNO_TIMEOUT
#Note: this is a special "exit code" since it's > 255 it won't be confused
#      with the task's exit code.

N7_EOT=$(openssl rand -hex 16) # "End Of Task" marker
#
# At the end of each a task execution, N7 outputs an EOT line of this form:
#
#   "$N7_EOT $host $N7_TASK_IDX $? changed"
#
# where $host is the hostname N7 used to ssh into the host, $N7_TASK_IDX is
# integral index of the task into the N7_TASKS array, and $? is  the exit
# status of the last command run by the task. 'changed' indicates whether
# the task has changed the state of the system, and if not, then it's should
# be a single '-' character instead of 'changed'. Within a task, an user
# can call the 'N7::remote::tasks::touch_changed' function to mark the task
# as changed the system state.
#

N7_NL=$'\n'


N7_DIR=${N7_DIR:-/tmp/n7} && mkdir -p "$N7_DIR"
N7_DIR=$(cd "${N7_DIR:-/tmp/n7}" && pwd)
N7_RUN_ID=$(printf "%d_%(%s)T" $$ -1)
N7_RUNS_DIR=$N7_DIR/runs
N7_RUN_DIR=$N7_RUNS_DIR/$N7_RUN_ID
declare -r N7_DIR N7_RUN_ID N7_RUNS_DIR N7_RUN_DIR

mkdir -p "$N7_DIR" "$N7_DIR/tmp" "$N7_RUNS_DIR" "$N7_RUN_DIR"

# used for temporarily storing updated N7_EHOSTS by a local task.
N7_EHOSTS_FILE=${N7_EHOSTS_FILE:-$N7_RUN_DIR/.ehosts}

# where stderr goes during N7 init or process clean up.
# mainly used to silence N7's init task outputs and 
# bash's child-process-got-killed message during process clean up.
N7_INTERNAL_ERR_FILE=$N7_RUN_DIR/.cleanup.err

# The command to run sudo. Options can be added too.
# Eg, N7_SUDO='sudo -u someone'
#
# This is mainly used by N7's built-in functions(eg, N7::local::files::cp()).
# It can also be overriden by the `sudo` option of the built-in functions
# that support it. In your own task you can just run sudo by yourself.
N7_SUDO=${N7_SUDO:-sudo}

# Where N7 store temporary file on a remote host.
N7_REMOTE_TMP_DIR=/var/tmp/n7
N7_REMOTE_RUN_DIR=$N7_REMOTE_TMP_DIR/$N7_RUN_ID

N7_SSH_OPTS=${N7_SSH_OPTS:-"
  -o BatchMode=yes
  -o PasswordAuthentication=no
  -o ControlMaster=auto
  -o ControlPersist=60s 
  -o ControlPath=$N7_DIR/tmp/n7-ssh-%h-%p-%r
"}
N7_SSH_CMD="ssh $(printf "%s " $N7_SSH_OPTS)"
N7_SSH_PIDs=$N7_RUN_DIR/.ssh.pids
N7_SSH_PPIDs=()
N7_SSH_PIPE_FDs=()  # file descriptors redirected to write to the SSH read pipes.
                    # these FDs exist mainly to keep the pipes open.

# stdout of the last ansible module executed.
N7_ANSIBLE_OUT=$N7_REMOTE_RUN_DIR/ansible.out
declare -r N7_ANSIBLE_OUT
#@-<< globals >>

trap 'N7::cleanup' ABRT ERR TERM QUIT INT EXIT HUP

#@+<< local built-ins >>
#@+middle:jkuan.20140105132438.2229: ** N7 built-in functions
#@+node:jkuan.20140101001347.1715: *3* << local built-ins >>
# Functions under the N7::local "namespace" can only be used locally.

#@+others
#@+node:jkuan.20140109170044.1915: *4* N7::local::ansible::replace_mod
N7::local::ansible::replace_mod() {
    python - <<<"$(cat <<'EOF'
#@+<< ansible module replacer >>
#@+node:jkuan.20140109170044.1916: *5* << ansible module replacer >>
#@@language python
#@@first
#
# Tested with Ansible 1.4.4
#
# Usage: $0 <module_name> [name=value ...]
#
# If the last argument is a single '-' character then also
# read complex args(ie, YAML) from stdin.
#
# Outputs:
#   First line is the module style: 'new' or not 'new'.
#   The rest is the modified ansible module to be transferred to remote hosts.
#
# Note that if module style is not 'new' then you have to provide the arguments
# as stdin to the module when you execute it, and in this case, I believe,
# complex args is not supported.
#

import sys
import yaml

import ansible.utils
import ansible.errors
from ansible.module_common import ModuleReplacer

replacer = ModuleReplacer(True)

mod_name = sys.argv[1]
mod_src = ansible.utils.module_finder.find_plugin(mod_name)
if not mod_src:
    raise ansible.errors.AnsibleFileNotFound("module %s not found in %s" % (
        mod_name, ansible.utils.plugins.module_finder.print_paths()))

complex_args = {}

# if the last arg is a '-' then read stdin as complex args.
if sys.argv[-1] == '-': 
    complex_args = yaml.load(sys.stdin)
    del sys.argv[-1]

mod_args = ' '.join(sys.argv[2:])

inject = {}
mod_dump, mod_style, shebang = replacer.modify_module(mod_src, complex_args, mod_args, inject)

print mod_style
print mod_dump

#@-<< ansible module replacer >>
#@@raw
EOF
#@@end_raw
)" "$@"
}
#@+node:jkuan.20140109170044.1917: *4* N7::local::ansible::send_mod
# N7::local::ansible::send_mod <module_name> [name=value ...]
#
# Transfer an ansible module over to the remote hosts.
# The ansible module will be configured with the arguments specified if
# it's a new style module.
# 
N7::local::ansible::send_mod() {
    local data
    data=$(N7::local::ansible::replace_mod "$@") || return $?
    echo "$data" | (
        read mod_style
        tmpf=$N7_REMOTE_RUN_DIR/ansmod_${mod_style}.$(openssl rand -hex 16)
        echo $tmpf
        N7::local::files::cp <(cat) "$tmpf" mode=0755
    )
}
#@+node:jkuan.20140109170044.1918: *4* N7::local::ansible::run_mod
# N7::local::ansible::run_mod <module_name> [name=value ...]
#   
# Transfer and run an ansible module with the specified arguments.
#
# Environment vars that affect the command:
#
#   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
#            value to use as the command to sudo.

N7::local::ansible::run_mod() {
    local tmpf; tmpf=$(N7::local::ansible::send_mod "$@") || return 1
    local mod_style=$(basename "${tmpf%%.*}"); mod_style=${mod_style#ansmod_}

    if [[ $mod_style = new ]]; then
        N7::local::commands::remote "
            ${sudo:+$(N7::get_sudo "$sudo")} $tmpf | tee \$N7_ANSIBLE_OUT
            rm -f $tmpf
            N7::remote::ansible::check_status
        "
    else
        N7::local::commands::remote "
            ${sudo:+$(N7::get_sudo "$sudo")} $tmpf <<<$(N7::q $*) | tee \$N7_ANSIBLE_OUT
            rm -f $tmpf
            N7::remote::ansible::check_status
        "
    fi
}
#@+node:jkuan.20140101001347.1716: *4* N7::local::utils::trap
#
# Wrapper around Bash's built-in trap command.
# It takes care not to overwrite existing commands already assigned to a signal.
#
# Use it instead if you would like to use trap in your N7 script.
#
N7::local::utils::trap() {
    local cmd=$1; shift
    local signal cur_cmd;
    for signal in $*; do
        cur_cmd=$(trap -p $signal)
        cur_cmd=${cur_cmd#*\'}
        cur_cmd=${cur_cmd%\'*}
        trap "${cur_cmd:+"$cur_cmd;"} $cmd" $signal
    done
}
#@+node:jkuan.20140101001347.1717: *4* N7::local::commands::remote
#
# Run cmd on all remote hosts.
# The command will be run in a subshell unless the env var N7_NO_SUBSHELL is
# set for the command. Eg, N7_NO_SUBSHELL=1 N7::local::commands::remote "echo hello"
#
# Return 0 if the command was run successfully on all remote hosts;
# return 1 otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::remote() {
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        [ "$N7_NO_SUBSHELL" ] || N7::send_cmd '(' $host
        N7::send_cmd "$1"                         $host
        [ "$N7_NO_SUBSHELL" ] || N7::send_cmd ')' $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}
#@+node:jkuan.20140101001347.1718: *4* N7::local::commands::send_funcs
#
# Define the list of functions specified on the remote end.
# Abort n7 with an error if it can't locate all functions specified.
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 otherwise.
#
# Alternatively, you can define your remote helper functions within
# a remote task function that declares ': NO_SUBSHELL=1' so that when
# the task is run remotely, all the functions within it will be defined
# globally for later tasks.
#
# This function can only be used from a local task.
#
N7::local::commands::send_funcs() {
    local name funcs=() failed=()
    for name in $*; do
        funcs+=("$(declare -f "$name")") || failed+=("$name")
    done
    [ "$failed" ] && N7::die "Failed locating functions: ${failed[*]}"

    local f hosts=$(N7::ssh_ehosts)
    for f in "${funcs[@]}"; do
        N7_NO_SUBSHELL=1 N7::local::commands::remote "$f"
    done
    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}
#@+node:jkuan.20140101001347.1719: *4* N7::local::commands::send_env
#
# Define environment variables on all remote hosts.
# Space and special shell characters will need to be quoted.
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::send_env() {
    local host name_value hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        for name_value in "$@"; do
            N7::send_cmd "export $(N7::q "$name_value") &&" $host
        done
        N7::send_cmd "true" $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}
#@+node:jkuan.20140101001347.1720: *4* N7::local::commands::n7
#
# Run n7 in a subshell with the current effective hosts.
#
N7::local::commands::n7() {
    echo $N7_EHOSTS | N7_EHOSTS_FILE=$N7_EHOSTS_FILE "$0" "$@"
}
#@+node:jkuan.20140101001347.1721: *4* N7::local::files::cp
#
# Copy a file from localhost to the remote hosts.
# Any host it fails to copy the file to will be removed from $N7_EHOSTS.
# Return 0 if the file is copied to all hosts successfully; return 1 otherwise.
#
# Options are name=value pairs. Quotes are needed to escape space and other
# special characters.
#
# Known options are: `owner`, `group`, and `mode` for setting the file owner,
# group, and permission mode of the file. `mode` must be numeric with octal digits.
#
# Environment vars that affect the command:
#
#   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
#            value to use as the command to sudo.
#
# This function can only be used from a local task one at a time. 
#
N7::local::files::cp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
    done

    local _sudo=${sudo:+$(N7::get_sudo "$sudo")}
    local host hosts=$(N7::ssh_ehosts)
    local encoded=$(base64 <"$src")
    for host in $hosts; do
        N7::send_cmd "echo \"$encoded\" | base64 --decode |
        (  $_sudo tee $dest >/dev/null &&
                sudo="$sudo" N7::remote::files::file $dest $(N7::qm "$@")
        )" $host
        N7::send_eot_line $host '$(( $(echo ${PIPESTATUS[*]} | tr " " \|) ))'
    done

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}
#@+node:jkuan.20140101001347.1722: *4* N7::local::files::cp_tpl
#
# Copy a file from localhost to the remote hosts.
# The file content is subject to parameter expansions and process substitutions.
#
# All options are passed to N7::local::files::cp.
#
# Any host it fails to copy the file to will be removed from $N7_EHOSTS.
# Return 0 if the file is copied to all hosts successfully; return 1 otherwise.
#
# This function can only be used from a local task one at a time. 
#
N7::local::files::cp_tpl() {
    local src=$1 dest=$2; shift; shift
    local tmpf=$(N7::mktemp)
#@@raw
    (source <(echo "cat <<EOF
$(<"$src")
EOF
#@@end_raw
")) >"$tmpf" || N7::die "Failed evaluating template: $src"

    N7::local::files::cp "$tmpf" "$dest" "$@"
    local rc=$?
    rm -f "$tmpf"
    return $rc
}
#@+node:jkuan.20140101001347.1723: *4* N7::local::files::scp
#
# This is an alternative implementation of N7::local::files::cp() that uses scp
# instead. It first scp the source file to a temporary file and then move it over
# to the destination if the scp was successful. It might be faster and safer for
# large files.
#
N7::local::files::scp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
    done

    local tmpdir=$(N7::q "$N7_REMOTE_TMP_DIR")
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        N7::send_cmd "tmpdir=$tmpdir mktemp -t .tmp.XXXXXXXXXXX" $host
        #FIXME: tmp file name shows up in stdout...
        N7::send_eot_line $host \$?
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)

    local tmpf pids=()
    local -A tmpfiles=()
    for host in $hosts; do
        tmpf=$(N7::local::tasks::get_stdout $host $N7_TASK_IDX | tail -2 | head -1)
        tmpfiles[$host]="$tmpf"
        scp $N7_SSH_OPTS "$src" "$host:$tmpf" &
        pids+=($host,$!)
    done

    local _sudo=${sudo:+$(N7::get_sudo "$sudo")}

    local host_pid 
    for host_pid in ${pids[*]}; do
        host=${host_pid%,*}
        src=$(N7::q "${tmpfiles[$host]}")
        N7::send_cmd ": N7::local::files::scp $src $dest" $host
        if wait ${host_pid#*,}; then
            N7::send_cmd "
                $_sudo mv $src $dest &&
                sudo="$sudo" N7::remote::files::file $dest $(N7::qm "$@")
            " $host
            N7::send_eot_line $host \$?
        else
            N7::send_eot_line $host 1
        fi
    done

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}
#@+node:jkuan.20140101001347.1724: *4* N7::local::tasks::get_stdout
#
# Output the stdout of the task with <task_idx> from <hostname>
#
N7::local::tasks::get_stdout() {
    [ "$2" -ge 0 ] &&
    awk 'BEGIN { i = 0 }
    { if ($0 !~ "^'$N7_EOT'")
        lines[i++] = $0
      else {
        if ($3 == "'$2'")
          for (e=0; e < i; e++)
            print lines[e];
        i=0;
      } 
    }' "$(N7::ssh_out_file $1)"
}
#@+node:jkuan.20140101001347.1725: *4* N7::local::tasks::get_stderr
#
# Output the stderr of the task with <task_idx> from <hostname>
#
eval "$(declare -f N7::local::tasks::get_stdout \
         | sed -e 's/stdout/stderr/
                   s/_out_/_err_/'
       )"
#@-others

#@-<< local built-ins >>

# This remote task defines N7's remote built-in functions.
# It is run here so that those functions will also be available locally as well.
.N7::define_builtins

#-------------

set +e

#N7::run_tasks_on_hosts "tasks..." "hosts..."
#
N7::run_tasks_on_hosts() {
    local tasks=$1 hosts=$2
    if [ "$N7_SSH_COUNT" ]; then
        while read hosts; do
            N7::run_tasks "$tasks" "${hosts}"
        done < <(tr ' ' '\n' <<<$hosts | paste -d' ' $(seq -f - ${N7_SSH_COUNT}))
    else
        N7::run_tasks "$tasks" "$hosts"
    fi
    [ "$(N7::ssh_ehosts)" = "$N7_HOSTS" ]
}

# Load user's .n7 script
if [ "$N7_SCRIPT" ]; then
    source "$N7_SCRIPT" "${N7_SCRIPT_ARGS[@]}" || N7::die "Failed loading $N7_SCRIPT!"
fi

# We've given the .n7 script the chance to mess with some of the globals,
# now make them read-only.
declare -r \
    N7_EOT \
    N7_SUDO \
    N7_TASK_TIMEOUT \
    N7_DEFAULT_TASK_TYPE \
    N7_SSH_OPTS \
    N7_SSH_CMD 

N7::load_tasks
N7::load_task_opts ${N7_TASKS[*]}

# Run N7 built-in tasks first
N7::run_tasks_on_hosts "${N7_BUILTIN_TASKS[*]}" "${N7_HOSTS[*]}" >>"$N7_INTERNAL_ERR_FILE" 2>&1 ||
    N7::die "Failed initializing remote hosts!"

N7::scope_do() {
    local i host length=${#N7_BUILTIN_TASKS[*]}

    # Remove built-in tasks like it never happened
    for ((i=0; i < length; i++)); do
        unset N7_TASK_OPTS_$i
        unset N7_TASKS[$i]
    done
    N7_TASKS=(${N7_TASKS[*]})
    N7::load_task_opts ${N7_TASKS[*]}
    for host in ${N7_HOSTS[*]}; do
        : > "$(N7::ssh_out_file $host)"
        : > "$(N7::ssh_err_file $host)"
        # ssh doesn't know that we just truncated the files. This results in
        # null bytes at the beginning of the files. So, we write an EOT line
        # with task id == -1 to make the output of task 0 starts on a newline,
        # and to avoid the null bytes from appearing as task 0's output.
        N7::send_eot_line $host -1 0
    done
}; N7::scope_do; unset -f N7::scope_do
declare -r N7_TASKS

# Run user's N7 tasks
N7::log "Run id=$N7_RUN_ID -- N7_DIR=$(N7::q "$N7_DIR") N7_EOT=$N7_EOT"
N7::run_tasks_on_hosts "${N7_TASKS[*]}" "${N7_HOSTS[*]}"

#@-leo
