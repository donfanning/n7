#!/bin/bash
#
# N7 - Ad Hoc Task Automation and Orchestration in Bash.
#
# TODO:
#   - allow a task to touch a file to indicate something has changed.
#   - ansible module integration
#   - write tests, run tests using docker
#   - show also stderr for tasks with non-zero exit status
#   - add example .n7 scripts
#   - show colorized output
#

#set -x

set -e

declare -A N7_LOG_LEVELS=([DEBUG]=-1 [INFO]=0 [WARNING]=1 [ERROR]=2 [FATAL]=3)
declare -i N7_VERBOSE=${N7_LOG_LEVELS[INFO]}

N7::log() {
    local level=${2:-"INFO"}; 
    local -i ilevel=${N7_LOG_LEVELS[$level]?:"Invalid log level: $level"}
    if [ "$ilevel" -ge "$N7_VERBOSE" ]; then
        echo "$(date +%Y-%m-%dT%T%z)|N7|$(whoami)|$level $1"
    fi
}
N7::die() { N7::log "$1" ${2:-ERROR} >&2; exit 1; }

N7::usage() {
  echo "$(echo "\
    Usage: $(basename "$0") [options] [cmd1 cmd2 ...]

    Each command, if provided, will be run as a N7 task with default task options.

    Options:
      -h          Show this help. 

      -m HOSTS    A list of comma separated hosts. Hosts will be read from
                  STDIN(one host per line) if the -m option is not specified.

      -s FILE     Source and execute tasks in FILE after running the commands
                  specified on the command line.

      -v LEVEL    Set the verbose level. Defaults to INFO.
                  Levels available: $(
                       for k in ${!N7_LOG_LEVELS[*]}; do
                           echo ${N7_LOG_LEVELS[$k]} $k
                       done | sort -n | cut -d' ' -f2 | xargs
                  )

      -o          Show task stdout at the end of a task from each host.
                  Local and command-line task outputs are always shown unless you
                  redirect them in the task.

      -k          Keep the run directory after execution. The run directory, which
                  is unique to each n7 invocation, stores the runtime files such as
                  stdout and stderr files from each remote host, etc.

      -p COUNT    Limit the number of parallel SSH processes to COUNT at a time.
                   

" | sed -e 's/    //')"
}

while getopts ':hs:m:v:okp:' option; do
    case $option in
        s) N7_SCRIPT=$OPTARG ;;
        m) N7_HOSTS=$(tr , ' ' <<<"$OPTARG") ;;
        v) N7_VERBOSE=${N7_LOG_LEVELS[$OPTARG]?:"Invalid log level: $OPTARG"} ;;
        o) N7_TASK_SHOW_STDOUT=1 ;;
        k) N7_KEEP_RUN_DIR=1 ;;
        p) declare -r N7_SSH_COUNT=$OPTARG 
           [ "$N7_SSH_COUNT" -gt 0 ] ||
               N7::die "Invalid value($N7_SSH_COUNT) for the -p option!"
            ;;
        h) N7::usage; exit ;;
        :) N7::die "Missing option argument for -$OPTARG" ;;
        \?) N7::die "Unknown option: -$OPTARG" ;;
    esac
done
unset option
shift $(($OPTIND - 1))

# Read from stdin a list of hostnames, one per line, to ssh into.
if [ ! "$N7_HOSTS" ]; then N7_HOSTS=$(</dev/stdin); fi

# De-duplicate the hostnames
N7_HOSTS=$(echo $N7_HOSTS | tr ' ' '\n' | sort | uniq)
declare -r N7_HOSTS
#FIXME: should use host:port combination rather than just host

# Task definitions are just bash functions defined in a script.
# Any function named with a `.' prefix is a task.
declare -r N7_SCRIPT

# Function name prefix for command-line tasks.
N7_CLI_TASK_PREFIX=.N7::cli_task::

# If command line commands are provided then wrap the commands
# in N7 tasks.
i=0
for cmd in "$@"; do
    eval "${N7_CLI_TASK_PREFIX}$i() { : REMOTE=1
        $cmd
    }"
    let ++i
done
unset cmd i

# Task names in execution order.
N7_TASKS=()
N7_BUILTIN_TASKS=(.N7::init_local .N7::init_remote .N7::define_builtins)

# In case no LOCAL nor REMOTE task option is set for a task, this will
# be the default.
N7_DEFAULT_TASK_TYPE=${N7_DEFAULT_TASK_TYPE:-LOCAL}


# Each task can optionally have leading null commands that specifies task specific
# options. See the `N7::load_task_opts' function for the exact format.
# Known task options are:
N7_TASK_OPT_NAMES=(
  DESCRIPTION     # describe what the task does.
  TIMEOUT         # timeout in seconds for the remote task.
  NO_SUBSHELL     # set it to run the remote task directly in the N7 login shell.

  LOCAL           # set it to run the task locally.
  REMOTE          # set it to run the task remotely.

  #Note: If both LOCAL and REMOTE are set then the task type will be unknown.
  #      If neither LOCAL nor REMOTE is set then, the task is of the
  #      $N7_DEFAULT_TASK_TYPE, which defaults to LOCAL.

  IGNORE_STATUS   # set it to run the remaining tasks even if the task exited
                  # with a non-zero exit status. 
)
declare -r N7_TASK_OPT_NAMES

N7_TASK_TIMEOUT=${N7_TASK_TIMEOUT:-60}  # default task timeout, in seconds.
N7_ERRNO_TIMEOUT=999  # a task exits with this exit code if it's timed out.
declare -r N7_ERRNO_TIMEOUT
#Note: this is a special "exit code" since it's > 255 it won't be confused
#      the task's exit code.

N7_EOT=$(openssl rand -hex 16) # "End Of Task" marker
declare -r N7_EOT
#
# At the end of each a task execution, N7 outputs an EOT line of this form:
#
#   "$N7_EOT $host $N7_TASK_IDX $?"
#
# where $host is the hostname N7 used to ssh into the host, $N7_TASK_IDX is
# integral index of the task into the N7_TASKS array, and $? is, of course,
# the exit status of the last command run by the task.
#

N7_NL=$'\n'


N7_DIR=${N7_DIR:-/tmp/n7} && mkdir -p "$N7_DIR"
N7_DIR=$(cd "${N7_DIR:-/tmp/n7}" && pwd)
N7_RUN_ID=$$_$(date +%s)
N7_RUNS_DIR=$N7_DIR/runs
N7_RUN_DIR=$N7_RUNS_DIR/$N7_RUN_ID
declare -r N7_DIR N7_RUN_ID N7_RUNS_DIR N7_RUN_DIR

mkdir -p "$N7_DIR" "$N7_DIR/tmp" "$N7_RUNS_DIR" "$N7_RUN_DIR"

# used for temporarily storing updated N7_EHOSTS by a local task.
N7_EHOSTS_FILE=$N7_RUN_DIR/.ehosts

# stdout of all local tasks go here.
N7_LOCAL_OUT_FILE=$N7_RUN_DIR/localhost.out

# where stderr goes during process clean up.
# mainly used to silence bash's child-process-got-killed message.
N7_CLEANUP_ERR_FILE=$N7_RUN_DIR/.cleanup.err

# The command to run sudo. Options can be added too.
# Eg, N7_SUDO='sudo -u someone'
#
# This is mainly used by N7's built-in functions(eg, N7::local::files::cp()).
# It can also be overriden by the `sudo` option of the built-in functions
# that support it. In your own task you can just run sudo by yourself.
N7_SUDO=${N7_SUDO:-sudo}
declare -r N7_SUDO

# Where N7 store temporary file on a remote host.
N7_REMOTE_TMP_DIR=/var/tmp/n7

N7_SSH_OPTS=${N7_SSH_OPTS:-"
  -o BatchMode=yes
  -o PasswordAuthentication=no
  -o ControlMaster=auto
  -o ControlPersist=60s 
  -o ControlPath=$N7_DIR/tmp/n7-ssh-%h-%p-%r
"}
N7_SSH_CMD="ssh $(printf "%s " $N7_SSH_OPTS)"
N7_SSH_PIDs=$N7_RUN_DIR/.ssh.pids
N7_SSH_PPIDs=()
N7_SSH_PIPE_FDs=()  # file descriptors redirected to write to the SSH read pipes.
                    # these FDs exist mainly to keep the pipes open.

N7::close_ssh_pipes() {
    local fd pid_pgid host
    for fd in ${N7_SSH_PIPE_FDs[*]}; do
        eval "exec $fd>&-"
    done

    # kill ssh processes
    [ -r "$N7_SSH_PIDs" ] && {
        kill $(<"$N7_SSH_PIDs") >/dev/null 2>&1
        rm "$N7_SSH_PIDs"
    }

    # kill -9 each of the whole process groups that's reading the ssh pipes.
    for pid_pgid in $(ps x -opid,pgid | awk 'NR==1 {next}; {printf("%d,%d\n", $1, $2)}'); do
        if [[ " ${N7_SSH_PPIDs[*]} " =~ " ${pid_pgid%,*} " ]]; then
            kill -9 -- -${pid_pgid#*,} >/dev/null 2>&1
        fi
    done

    for host in $N7_HOSTS; do
        rm -f "$(N7::ssh_read_pipe $host)"
    done
}

trap 'N7::cleanup' ABRT ERR TERM QUIT INT EXIT HUP
N7::cleanup() {
    # this is to silence bash from reporting to stderr that a
    # child process was killed with SIGKILL.
    exec 2>>"$N7_CLEANUP_ERR_FILE"
    
    N7::close_ssh_pipes
    rm -f "$N7_EHOSTS_FILE"
    if [ ! "$N7_KEEP_RUN_DIR" ]; then
        rm -rf "$N7_RUN_DIR"
    fi
}

N7::ssh_read_pipe() { echo "$N7_RUN_DIR/$1.pipe_r"; }
N7::ssh_out_file() { echo "$N7_RUN_DIR/$1.out"; }
N7::ssh_err_file() { echo "$N7_RUN_DIR/$1.err"; }
N7::ssh_host_from_out_file() { echo $(basename "${1%.out}"); }
N7::send_cmd() { printf "%s\n" "$1" >"$(N7::ssh_read_pipe ${2:?'Empty host!'})"; }

N7::send_eot_line() {
    N7::send_cmd "echo $N7_EOT ${1:--} ${N7_TASK_IDX:--1} ${2:-\$?} | tee /dev/stderr" $1

#    local changed_f=$(N7::task_state_changed) #FIXME
#    # the line is: <eot_hash> <hostname> <task_index> <exit_status> <changed|->
#    N7::send_cmd "echo $N7_EOT ${1:--} ${N7_TASK_IDX:--1} ${2:-\$?} \
#                       \$([ -e $(N7::q "$changed_f") ] && echo changed || echo -) |
#                  tee /dev/stderr
#    " $1
}


N7::is_num() { [ "$1" ] && printf "%.0f" "$1" >/dev/null 2>&1; }
N7::mktemp() {
    tmpdir=$n7_run_dir mktemp -t .tmp.XXXXXXXXXXX ||
        N7::die "Failed creating a temporary file!"
}
N7::ssh_ehosts() {
    if [ -r "$N7_EHOSTS_FILE" ]; then
        local out=$(<"$N7_EHOSTS_FILE") 2>/dev/null
        rm -f "$N7_EHOSTS_FILE"
    fi
    echo ${out:-$N7_EHOSTS}
}


# N7::load_tasks
#
# Load up N7_TASKS with task names in the order they are defined in N7_SCRIPT.
#
N7::load_tasks() {
    # Add built-in tasks
    N7_TASKS+=(${N7_BUILTIN_TASKS[*]})

    # Add command-line tasks
    N7_TASKS+=($(declare -f | grep "^\.N7::cli_task::" | cut -d' ' -f1 | sort -t: -nk5))
    #FIXME: use N7_CLI_TASK_PREFIX, but need to escape regex chars...

    shopt -s extdebug
    N7_TASKS+=($(
        for f in $(declare -f | grep '^\.' | cut -d' ' -f1); do
            line=$(declare -F $f)
            p=${line#* }; p=${p#* }
            if [ "$p" = "$N7_SCRIPT" ]; then printf "%s\n" "$line"; fi
        done | sort -nk2 | cut -d' ' -f1)
    )
    shopt -u extdebug
    if [ ${#N7_TASKS[*]} -eq 0 ]; then
        N7::log "No tasks are defined!" WARNING
    fi
}


# N7::parse_task_opts <task_defn>
#
# Take a function definition, parse all leading null commands(:) of the form:
#
#     ': name1=value1'
#     ': name2=value2'
# 
# until the first non-null command, which marks the end of the task option section.
#
# Output the right hand side of an associative array assignment of this form:
#
#     '([name1]=value1
#      [name2]=value2
#        ...
#      )'
#
N7::parse_task_opts() {
    local section=$(awk '/^ *: /, $0 ~ "^ *[^#]" && $0 !~ "^ *: " {print}' <<<"$(declare -f $1)")
    echo "("
    echo "$section" | sed '$d
      s/^ *:  *//g 
      s/\([^ ]\)/\[\1/ 
      s/=/\]=/
      s/;$//
    '
    echo ")"
}

# Usage: N7::get_task_opt <task_idx> <opt_name>
N7::get_task_opt() {
    local task_opt="N7_TASK_OPTS_$1[$2]"
    printf "%s\n" "${!task_opt}"  
}

# N7::load_task_opts <all task definitions...>
#
# Dynamically assign a global array variable, N7_TASK_OPTS_{n}.
#
# So as an example, for the first task(task 0) you have N7_TASK_OPTS_0.
# The options in such array can be obtained via the `N7::get_task_opt' function.
#
N7::load_task_opts() {
    local task_idx=-1 task task_opts name val
    while [[ $# > 0 ]]; do
        name=N7_TASK_OPTS_$((++task_idx))
        task=$1; shift
        task_opts=$(N7::parse_task_opts "$task")

        #HACK: if there's a syntax error with the array assignment then this will exit 1.
        set -e; source <(echo "declare -gA $name; $name=$task_opts"); set +e

        # check if each option name is valid
        val=($(eval echo '${!'$name'[*]}'))
        for name in ${N7_TASK_OPT_NAMES[*]}; do val=(${val[*]/#$name}); done
        if [ "$(echo ${val[*]})" ]; then   #FIXME: option value might conflict with echo's options
            N7::die "Invalid task options(${val[*]}) in task #$task_idx"
        fi
        
        # validate the TIMEOUT value
        val=$(N7::get_task_opt $task_idx TIMEOUT)
        [ ! "$val" ] || [ "$val" -gt 0 ] || N7::die "Invalid timeout(\`$val') for task #$task_idx!"

        # set NAME to function name if it's not specified.
        if [ ! "$(eval echo \${N7_TASK_OPTS_$task_idx[NAME]})" ]; then
            eval N7_TASK_OPTS_$task_idx[NAME]=$task
        fi

        # deal with LOCAL and REMOTE
        val=N7_TASK_OPTS_$task_idx
        if [ "$(eval echo \${$val[REMOTE]})" ]; then
            eval unset $val[LOCAL]
        elif [ "$(eval echo \${$val[LOCAL]})" ]; then
            eval unset $val[REMOTE]
        else
            eval $val[$N7_DEFAULT_TASK_TYPE]=1
        fi
    done
}


# N7::wait_for_tasks_on_hosts <task_idx> [host1 host2 ...]
#
# Periodically look at the last line of each host out-file, expecting the EOT marker.
#
# If the EOT line is found at the end within task timeout, then it means the last
# task has finished. Otherwise, the task has been timed out.
#
# Output the EOT lines. For timed out hosts, the rc field of the EOT line will be
# set to $N7_ERRNO_TIMEOUT.
#
N7::wait_for_task_on_hosts() {
    local task_idx=$1; shift
    local timeout=$(N7::get_task_opt $task_idx TIMEOUT)
    local out_files=$(for h in $*; do N7::ssh_out_file $h; done)
    local eot_lines

    timeout=${timeout:-$N7_TASK_TIMEOUT}
    SECONDS=0
    while (( SECONDS < timeout )); do
        sleep 0.01
        eot_lines=$(IFS=$'\n'; tail -v -n1 $out_files | grep -aPB1 "^$N7_EOT [^ ]+ \b$task_idx\b \d+$")
        # Note: with tail's '==> path <==' headers.

        out_files=$(
            diff <(echo "$eot_lines" | grep "^==>" | cut -d' ' -f2 | sort) \
                 <(echo "$out_files" | sort) | grep '^>' | cut -d' ' -f2
        )
        [ "$eot_lines" ] && grep "^$N7_EOT" <<<"$eot_lines"
        [ ! "$out_files" ] && return # ie, all out files have the EOT at the end.

    done
    local path oIFS=$IFS
    IFS=$'\n'
    for path in $out_files; do
        echo "$N7_EOT $(N7::ssh_host_from_out_file "$path") $task_idx $N7_ERRNO_TIMEOUT"
    done
    IFS=$oIFS
}

# N7::wait_for_task <task_idx> [host1 host2 ...]
#
# Wait for task to finish running until a timeout on each host.
# Outputs a string of hosts that N7 will be using for running the next task.
#
N7::wait_for_task() {
    local task_idx=$1; shift
    local hosts=$*
    local host rc from_line out_file

    local task_name=${N7_TASKS[$task_idx]}
    [[ $N7_TASK_SHOW_STDOUT || ${task_name/#$N7_CLI_TASK_PREFIX} != $task_name  ]]
    local show_output=$?

    # wait for the EOT marker at the end in each host's out file
    while read _ host _ rc; do
        if [ "$show_output" = 0 ]; then
            out_file=$(N7::ssh_out_file $host)
            if [ "$task_idx" = 0 ]; then 
                from_line=1
            else
                from_line=$(grep -an "^$N7_EOT $host $((task_idx-1)) " "$out_file" | tail -n1 | cut -d: -f1)
                let ++from_line
            fi
            tail -n+$from_line "$out_file" >&2 
        else
            N7::log "$host rc=$rc" >&2
        fi

        if [ "$rc" != 0 ]; then

            # remove timed out host so that it won't block the next task
            if [ "$rc" = $N7_ERRNO_TIMEOUT ]; then
                hosts=$(echo ${hosts/$host})

            # remove failed host if the task has no IGNORE_STATUS set
            elif [ ! "$(N7::get_task_opt $task_idx IGNORE_STATUS)" ]; then
                hosts=$(echo ${hosts/$host})
            fi
        fi
        #NOTE: if a task is timed out but has IGNORE_STATUS set, and
        #  is actually still executing, it will block the tasks after
        #  it(because all tasks for a host share one ssh pipe), thus
        #  its following tasks are likely also going to be timed out.
    done < <(N7::wait_for_task_on_hosts $task_idx $hosts)
    echo $hosts
}


# N7::ssh_connect [host1 host2 ...]
#
N7::ssh_connect() {
    local host ssh_pipe ssh_out ssh_err fd
    for host in $*; do
        ssh_pipe=$(N7::ssh_read_pipe $host)
        if [ -e "$ssh_pipe" ]; then
            continue
        fi
        ssh_out=$(N7::ssh_out_file $host)
        ssh_err=$(N7::ssh_err_file $host)
        mkfifo "$ssh_pipe" || N7::die "Failed making named pipes for ssh!"
        set -m  # temporarily enable job control to create the following
        (       # subshell in its own process group.
          $N7_SSH_CMD $host 'exec -l /bin/bash' <"$ssh_pipe" >"$ssh_out" 2>"$ssh_err" &
          ssh_pid=$!
          echo $ssh_pid >>"$N7_SSH_PIDs"
          wait $ssh_pid
          if [ $? -gt 0 -a $? -lt 128 ]; then
              N7::log "$(echo "SSH connection to $host disconnected!"; cat "$ssh_err")"
          fi

          # remove the ssh pid from the ssh pid file
          sed -i '' -e "/^$ssh_pid\$/d" "$N7_SSH_PIDs" >/dev/null 2>&1

          # make any further writes to the pipe fail without blocking,
          # then read from the pipe to unblock the process that had written
          # to it before the chmod.
          chmod a-w "$ssh_pipe" &&
          while true; do cat "$ssh_pipe" >/dev/null; done #FIXME: don't discard the data read?
        ) 2>>"$N7_CLEANUP_ERR_FILE" & set +m
        N7_SSH_PPIDs+=($!)

        # this is just to keep the pipe from being closed when its
        # write end closes.
        exec {fd}>"$ssh_pipe" || N7::die "Failed FD creations and redirections"
        N7_SSH_PIPE_FDs+=($fd)
    done
}

# N7::run_tasks <"task_name1 task_name2 ..."> ["host1 host2 ..."]
# 
# Execute the bash functions(tasks) named on all the hosts specified.
# Each task will be run on all hosts, and a task must finish its execution on all hosts
# before the next will be run. If a task execution fails or timed out on a host then
# that host will be removed from execution of any further tasks unless the task has
# its IGNORE_STATUS option set and is not timed out.
#
# Moreover, the following environment variables will be available to all tasks:
#
#   N7_TASK_IDX - The index number(0-based) of the current task.
#   N7_EHOSTS - "The effective hosts". A space separated list of hosts that the
#               current task is going through.
#
N7::run_tasks() {
    # the "effective" host list. It gets updated by `run_tasks()' while N7_HOSTS doesn't.
    local N7_EHOSTS=$(echo $2)

    # export it so this will be available to local tasks.
    export N7_EHOSTS

    set -- $1

    local host task
    local N7_TASK_IDX=-1 rc no_subshell sudo
    export N7_TASK_IDX

    export N7_TASKS # for local tasks

    N7::ssh_connect $N7_EHOSTS

    while [[ $# > 0 && -n "$N7_EHOSTS" ]]; do
        task=$1; shift
        let ++N7_TASK_IDX

        N7::log "Running Task #$N7_TASK_IDX: $(N7::get_task_opt $N7_TASK_IDX NAME) ..."

        # handle local task, which has no timeout control, and runs in a subshell.
        if [ "$(N7::get_task_opt $N7_TASK_IDX LOCAL)" ]; then
            ($task) >>"$N7_LOCAL_OUT_FILE"; rc=$?
            N7::log "localhost rc=$rc"
            if [ "$rc" != 0 -a ! "$(N7::get_task_opt $N7_TASK_IDX IGNORE_STATUS)" ]; then
                N7::die "Error running local task #$N7_TASK_IDX: $(N7::get_task_opt $N7_TASK_IDX NAME)"
            fi
            # the local task might invoke a function that changes N7_EHOSTS
            N7_EHOSTS=$(N7::ssh_ehosts)
            continue
        fi

        no_subshell=$(N7::get_task_opt $N7_TASK_IDX NO_SUBSHELL)

        # send the remote task to each host
        for host in $N7_EHOSTS; do
            N7::send_cmd "export N7_TASK_IDX=$N7_TASK_IDX N7_EHOSTS=\$(echo $N7_EHOSTS)" $host
            [ "$no_subshell" ] || N7::send_cmd '('             $host
                                  N7::send_cmd $task           $host
            [ "$no_subshell" ] || N7::send_cmd ') </dev/null'  $host
            N7::send_eot_line $host
        done

        N7_EHOSTS=$(N7::wait_for_task $N7_TASK_IDX $N7_EHOSTS)
    done
}


#--- N7 built-in functions -----------------------
#
# Functions under the N7::local "namespace" can only be used locally.
# Functions under the N7::remote "namespace can be used both remotely and locally.
#
#


# N7::local::utils::trap cmd signal_spec1 signal_spec2 ...
#
# Wrapper around Bash's built-in trap command.
# It takes care not to overwrite existing commands already assigned to a signal.
#
# Use it instead if you would like to use trap in your N7 script.
#
N7::local::utils::trap() {
    local cmd=$1; shift
    local signal cur_cmd;
    for signal in $*; do
        cur_cmd=$(trap -p $signal)
        cur_cmd=${cur_cmd#*\'}
        cur_cmd=${cur_cmd%\'*}
        trap "${cur_cmd:+"$cur_cmd;"} $cmd" $signal
    done
}

# N7::local::commands::remote <cmd>
#
# Run cmd on all remote hosts.
# The command will be run in a subshell unless the env var N7_NO_SUBSHELL is
# set for the command. Eg, N7_NO_SUBSHELL=1 N7::local::commands::remote "echo hello"
#
# Return 0 if the command was run successfully on all remote hosts;
# return 1 otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::remote() {
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        [ "$N7_NO_SUBSHELL" ] || N7::send_cmd '(' $host
        N7::send_cmd "$1"                         $host
        [ "$N7_NO_SUBSHELL" ] || N7::send_cmd ')' $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}

# N7::local::commands::send_funcs [name1 name2 ...]
#
# Define the list of functions specified on the remote end.
# Abort n7 with an error if it can't locate all functions specified.
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 otherwise.
#
# Alternatively, you can define your remote helper functions within
# a remote task function that declares ': NO_SUBSHELL=1' so that when
# the task is run remotely, all the functions within it will be defined
# globally for later tasks.
#
# This function can only be used from a local task.
#
N7::local::commands::send_funcs() {
    local name funcs=() failed=()
    for name in $*; do
        funcs+=("$(declare -f "$name")") || failed+=("$name")
    done
    [ "$failed" ] && N7::die "Failed locating functions: ${failed[*]}"

    local f hosts=$(N7::ssh_ehosts)
    for f in "${funcs[@]}"; do
        N7_NO_SUBSHELL=1 N7::local::commands::remote "$f"
    done
    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}

# N7::local::commands::send_env [name1=value1 name2=value2 ...]
#
# Define environment variables on all remote hosts.
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 if otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::send_env() {
    local host name_value hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        for name_value in "$@"; do
            N7::send_cmd "export $(N7::q "$name_value") &&" $host
        done
        N7::send_cmd "true" $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::files::cp <local_src_path> <remote_dest_path> [options]
#
# Copy a file from localhost to the remote hosts.
# Any host it fails to copy the file to will be removed from $N7_EHOSTS.
# Return 0 if the file is copied to all hosts successfully; return 1 otherwise.
#
# Options are name=value pairs. Quotes are needed to escape space and other
# special characters.
#
# Known options are: `owner`, `group`, and `mode` for setting the file owner,
# group, and permission mode of the file. `mode` must be numeric with octal digits.
#
# The `sudo` option is also available.
# If sudo=1 then the default $N7_SUDO will be used as the command to sudo;
# otherwise the value of `sudo` will be used.
#
# This function can only be used from a local task one at a time. 
#
N7::local::files::cp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        params[${nv%%=*}]=${nv#*=}
    done

    local sudo 
    sudo=${params[sudo]}
    sudo=${sudo:+$(N7::get_sudo "$sudo")}

    local host hosts=$(N7::ssh_ehosts)
    local encoded=$(base64 <"$src")
    for host in $hosts; do
        N7::send_cmd "echo \"$encoded\" | base64 --decode |
        (  $sudo tee $dest >/dev/null &&
                N7::remote::files::file $dest $(N7::qm "$@" "sudo=$sudo")
        )" $host
        N7::send_eot_line $host '$(( $(echo ${PIPESTATUS[*]} | tr " " \|) ))'
    done

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::files::cp_tpl <local_src_path> <remote_dest_path> [options]
#
# Copy a file from localhost to the remote hosts.
# The file content is subject to parameter expansions and process substitutions.
#
# All options are passed to N7::local::files::cp.
#
# Any host it fails to copy the file to will be removed from $N7_EHOSTS.
# Return 0 if the file is copied to all hosts successfully; return 1 otherwise.
#
# This function can only be used from a local task one at a time. 
#
N7::local::files::cp_tpl() {
    local src=$1 dest=$2; shift; shift
    local tmpf=$(N7::mktemp)
    (source <(echo "cat <<EOF
$(<"$src")
EOF
")) >"$tmpf" || N7::die "Failed evaluating template: $src"

    N7::local::files::cp "$tmpf" "$dest" "$@"
    local rc=$?
    rm -f "$tmpf"
    return $rc
}


# N7::local::files::scp <local_src_path> <remote_dest_path> [options]
#
# This is an alternative implementation of N7::local::files::cp() that uses scp
# instead. It first scp the source file to a temporary file and then move it over
# to the destination if the scp was successful. It might be faster and safer for
# large files.
#
N7::local::files::scp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        params[${nv%%=*}]=${nv#*=}
    done

    local tmpdir=$(N7::q "$N7_REMOTE_TMP_DIR")
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        N7::send_cmd "[ -d $tmpdir ] || mkdir -p $tmpdir" $host
        N7::send_cmd "tmpdir=$tmpdir mktemp -t .tmp.XXXXXXXXXXX" $host
        #FIXME: tmp file name shows up in stdout...
        N7::send_eot_line $host \$?
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)

    local tmpf pids=()
    local -A tmpfiles=()
    for host in $hosts; do
        tmpf=$(N7::local::tasks::get_stdout $host $N7_TASK_IDX | tail -2 | head -1)
        tmpfiles[$host]="$tmpf"
        scp $N7_SSH_OPTS "$src" "$host:$tmpf" &
        pids+=($host,$!)
    done

    local sudo
    sudo=${params[sudo]}
    sudo=${sudo:+$(N7::get_sudo "$sudo")}

    local host_pid 
    for host_pid in ${pids[*]}; do
        host=${host_pid%,*}
        src=$(N7::q "${tmpfiles[$host]}")
        N7::send_cmd ": N7::local::files::scp $src $dest" $host
        if wait ${host_pid#*,}; then
            N7::send_cmd "
                $sudo mv $src $dest &&
                N7::remote::files::file $dest $(N7::qm "$@" "sudo=$sudo")
            " $host
            N7::send_eot_line $host \$?
        else
            N7::send_eot_line $host 1
        fi
    done

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}



# N7::local:tasks::get_stdout <hostname> <task_idx>
#
# Output the stdout of the task with <task_idx> from <hostname>
#
N7::local::tasks::get_stdout() {
    [ "$2" -ge 0 ] &&
    awk 'BEGIN { i = 0 }
    { if ($0 !~ "^'$N7_EOT'")
        lines[i++] = $0
      else {
        if ($3 == "'$2'")
          for (e=0; e < i; e++)
            print lines[e];
        i=0;
      } 
    }' "$(N7::ssh_out_file $1)"
}

# N7::local:tasks::get_stderr <hostname> <task_idx>
#
# Output the stderr of the task with <task_idx> from <hostname>
#
eval "$(declare -f N7::local::tasks::get_stdout \
         | sed -e 's/stdout/stderr/
                   s/_out_/_err_/'
       )"

#-------------

#---N7 Default Intializing Tasks -----------

# This is the very first task that gets run by N7 to bootstrap remote
# tasks, and environment variables.
#
.N7::init_local() { : LOCAL=1; set -e
    # define remote tasks on remote hosts
    local task i=0
    for task in ${N7_TASKS[*]}; do
        if [ "$(N7::get_task_opt $i REMOTE)" ]; then
            N7::local::commands::send_funcs $task
        fi
        i=$((++i))
    done
    N7::local::commands::send_env "N7_SUDO=$(N7::q "$N7_SUDO")"
}

# This is the first remote task run by N7 to setup remote N7 built-ins
#
.N7::init_remote() {
    : REMOTE=1
    : NO_SUBSHELL=1

    # create N7 runtime directories
    #FIXME

}

.N7::define_builtins() { : REMOTE=1

    N7::q() { printf "%q\n" "$*"; }
    N7::qm() {
        local result=$(printf "%q " "$@")
        printf "${result% }\n"
    }
    N7::get_sudo() {
        local sudo=${1:-$N7_SUDO}
        if [ "$sudo" = 1 ]; then echo "$N7_SUDO"; else echo "$sudo"; fi
    }


    #
    # N7::remote::files::file <path> [options]
    #
    # Set file attributes. Options are:
    #
    #   owner  - owner name.
    #   group  - group name.
    #   mode   - file permission mode; only numeric octal digits allowed.
    #   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
    #            value to use as the command to sudo.
    #
    # This function can be use both remotely and locally.
    #
    N7::remote::files::file() {
        local path=$(N7::q "$1")
        declare -A params=()
        local nv
        for nv in "$@"; do
            params[${nv%%=*}]=${nv#*=}
        done
        local sudo=${params[sudo]}
        ${sudo:+$(N7::get_sudo "$sudo")} /bin/bash -s -- <<EOF
            owner=$(N7::q "${params[owner]}")
            group=$(N7::q "${params[group]}")
            mode=$(N7::q "${params[mode]}")
            mode=\${mode:-0\$(printf %o \$((0666 - \$(umask))))}
            rt=0
            read u g m < <(stat -c "%U %G %a" $path)
            if [[ \$owner ]]; then [[ \$u == \$owner ]] || { chown \$owner $path; rt=\$((\$? | rt)); }; fi
            if [[ \$group ]]; then [[ \$g == \$group ]] || { chgrp \$group $path; rt=\$((\$? | rt)); }; fi
            if [[ \$mode  ]]; then [[ \$m == \$mode  ]] || { chmod \$mode  $path; rt=\$((\$? | rt)); }; fi
            exit \$rt
EOF
    }
    
    N7::remote::tasks::touch_change() {
        [ -e "$N7_TASK_CHANGE_FILE" ] || touch $N7_TASK_CHANGE_FILE
    }

}
# Also run it immediately so they will be available locally as well.
.N7::define_builtins



#---------------
set +e

#N7::run_tasks_on_hosts "tasks..." "hosts..."
#
N7::run_tasks_on_hosts() {
    local tasks=$1 hosts=$2
    if [ "$N7_SSH_COUNT" ]; then
        while read hosts; do
            N7::run_tasks "$tasks" "${hosts}"
        done < <(tr ' ' '\n' <<<$hosts | paste -d' ' $(seq -f - ${N7_SSH_COUNT}))
    else
        N7::run_tasks "$tasks" "$hosts"
    fi
}

# Load user's .n7 script
if [ -r "$N7_SCRIPT" ]; then
    source "$N7_SCRIPT" || N7::die "Failed loading $N7_SCRIPT!"
fi
N7::load_tasks
N7::load_task_opts ${N7_TASKS[*]}


# Run N7 built-in tasks first
N7::run_tasks_on_hosts "${N7_BUILTIN_TASKS[*]}" "${N7_HOSTS[*]}" >/dev/null 2>&1 #FIXME: write to a file

# Remove built-in tasks like it never happened
for i in $(seq 0 $(( ${#N7_BUILTIN_TASKS[*]} - 1)) ); do
    unset N7_TASK_OPTS_$i
    unset N7_TASKS[$i]
done; N7_TASKS=(${N7_TASKS[*]})
N7::load_task_opts ${N7_TASKS[*]}
for host in ${N7_HOSTS[*]}; do
    : > "$(N7::ssh_out_file $host)"
    : > "$(N7::ssh_err_file $host)"
done


# Run user's N7 tasks
N7::log "Run id=$N7_RUN_ID -- N7_DIR=$N7_DIR"
N7::run_tasks_on_hosts "${N7_TASKS[*]}" "${N7_HOSTS[*]}"

