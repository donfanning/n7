#!/bin/bash
#
# N7 - Ad Hoc Task Automation and Orchestration in Bash.
#
# TODO:
#   - 

set -eE


declare -rA N7_LOG_LEVELS=([DEBUG]=-1 [INFO]=0 [WARNING]=1 [ERROR]=2 [FATAL]=3 [QUIET]=99)
declare -i N7_VERBOSE=${N7_LOG_LEVELS[INFO]}

N7::log() {
    local level=${2:-"INFO"}; 
    local -i ilevel=${N7_LOG_LEVELS[$level]?:"Invalid log level: $level"}
    if [[ $ilevel -ge $N7_VERBOSE ]]; then
        printf "%(%Y-%m-%dT%T%z)T|N7|%s|$level|%s\n" -1 "$USER" "$1"
    fi
}
N7::die() { N7::log "$1" ${2:-ERROR} >&2; exit 1; }
N7::debug() { N7::log "$1" DEBUG >&2; }

N7::print_stack_trace() {
    echo
    echo "Stack trace: --------"
    local i=0; while caller $((i++)); do :; done
    echo
    echo "Failed command: -->$BASH_COMMANDS<--"
} >&2

N7::is_num() { [[ $1 ]] && printf "%.0f" "$1" >/dev/null 2>&1; }
N7::is_int() { [[ $1 ]] && printf "%d" "$1" >/dev/null 2>&1; }


# A shared data stack, meant for passing small amount of data between function calls only.
#
# To push on to the stack:                DS+=("item1" "item2" ...)
# To pop the last item off the stack:     ${DS[-1]}; ds::pop
# To pop the last $N items off the stack: ${DS[@]:${#DS[@]}-N:N}; ds::pop $N
#
DS=()
ds::pop() {
    local len=${1:-1}
    while ((len--)); do
        unset DS["${#DS[@]} - 1"]
    done
}

trap "set +x; N7::print_stack_trace" ERR

#--- Process command line arguments or show usage --------------
#!/bin/bash

N7::usage() {
  echo "$(echo "\
    Usage: $(basename "$0") [options] [arg1 arg2 ...]

    Each argument, if provided, will be wrapped and run in a N7 *remote* task.
    However, If the -s option is provided then each argument will be passed to
    the N7 script as command line arguments.
        
    Options:
      -h          Show this help. 

      -m HOSTS    A list of comma separated hosts. If - is a member of HOSTS then
                  hosts will also be read from STDIN(space, tab, or newline separated),
                  and merged with HOSTS.

      -s FILE     Source and execute the N7 tasks in FILE.

      --          Mark the end of command-line options. The rest of command line
                  arguments won't be parsed as options to n7. This might be
                  useful for passing options specific to a n7 script.

      -v LEVEL    Set the verbose level. Defaults to INFO.
                  Levels available: $(
                       for k in ${!N7_LOG_LEVELS[*]}; do
                           echo ${N7_LOG_LEVELS[$k]} $k
                       done | sort -n | cut -d' ' -f2 | xargs
                  )

      -o          Show task stdout at the end of a task from each host.
                  Local and command-line task outputs are always shown unless you
                  redirect them in the task.

      -D          Do not redirect stderr to stdout for command line tasks.
                  The default is to do an 'exec 2>&1' at the beginning of each
                  command line task.

      -k          Keep the run directory after execution. The run directory, which
                  is unique to each n7 invocation, stores the runtime files such as
                  stdout and stderr files from each remote host, etc.

      -p COUNT    Limit the number of parallel SSH processes to COUNT at a time.

" | sed -e 's/    //')"
}

while getopts ':hs:m:v:oDkp:-' option; do
    case $option in
        s) N7_SCRIPT=$OPTARG; declare -r N7_SCRIPT ;;
        m) N7_HOSTS=$(tr , ' ' <<<"$OPTARG") ;;
        v) N7_VERBOSE=${N7_LOG_LEVELS[$OPTARG]?:"Invalid log level: $OPTARG"} ;;
        o) N7_TASK_SHOW_STDOUT=1 ;;
        D) N7_CLI_TASK_NO_REDIRECTION=1 ;;
        k) N7_KEEP_RUN_DIR=1 ;;
        p) declare -r N7_SSH_COUNT=$OPTARG 
           [[ $N7_SSH_COUNT -gt 0 ]] ||
               N7::die "Invalid value($N7_SSH_COUNT) for the -p option!"
            ;;
        h) N7::usage; exit ;;
        -) break ;;
        :) N7::die "Missing option argument for -$OPTARG" ;;
        \?) N7::die "Unknown option: -$OPTARG" ;;
    esac
done
unset option
shift $(($OPTIND - 1))

if [[ " $N7_HOSTS " =~ " - " ]]; then
    # Read from stdin a list of hostnames(space, tab, or newline separated)
    N7_HOSTS="$N7_HOSTS $(</dev/stdin)"
fi


#---------------------------------------------------------------


#--- Initialize global variables used by many core functions ---
#!/bin/bash

# De-duplicate the hostnames
N7_HOSTS=$(echo $(echo $N7_HOSTS | tr ' ' '\n' | sort -u | grep -v -- ^-\$))

# Separate hostname from its port in N7_HOSTS.
#
# Also make sure there's not a host with the same name but different ports.
# That is, ahost ahost:1234 is consider an error, and so is ahost:1234 ahost:5678
# In other words, we only allow one ssh connection per remote host.
#
declare -A N7_HOST_PORTS  # hostname -> :port
for host in $N7_HOSTS; do
    port=
    if [[ $host == *:*:*:* ]]; then # assume IPv6 address
        if [[ $host =~ \]: ]]; then
            port=${host##*]:}
            host=${host%]:$port}
            host=${host#[}
        fi
    else
        if [[ $host =~ : ]]; then
            port=${host##*:}
        fi
        host=${host%:$port}
    fi
    if [[ ${N7_HOST_PORTS["$host"]} ]]; then
        N7::die "Duplicate host entry($host) found in remote host list!"
    fi
    N7_HOST_PORTS["$host"]=:$port
done
unset host port

N7_HOSTS=${!N7_HOST_PORTS[*]}
declare -r N7_HOSTS
# N7_HOSTS now contains only hostnames. Port needs to be looked up in
# N7_HOST_PORTS.

[[ $N7_HOSTS ]] || { N7::log "Empty host list!" WARNING; exit 0; }

if [[ $N7_SCRIPT ]]; then
    N7_SCRIPT_ARGS=("$@")
fi

# If command line commands are provided then wrap the commands
# in N7 tasks.
if [[ ! $N7_SCRIPT ]]; then
    i=0
    for cmd in "$@"; do
        eval ".N7::cli_task::$i() {
            : REMOTE=1
          " $(if [[ ! $N7_CLI_TASK_NO_REDIRECTION ]]; then echo "exec 2>&1"; fi) "
            $cmd
        }"
        let ++i
    done
    unset cmd i
fi

# The "effective" host list. It gets updated by `run_tasks()' while N7_HOSTS doesn't.
N7_EHOSTS=

# Task names in execution order.
N7_TASKS=()
# NOTE: Task definitions are just bash functions defined in N7_SCRIPT.
#       Any function named with a `.` prefix is a task.


# These are N7 built-in tasks used to bootstrap N7.
N7_BUILTIN_TASKS=(
  .N7::init_local
  .N7::init_remote
  .N7::define_remote_builtins
)
declare -r N7_BUILTIN_TASKS

# Handlers are remote functions that have a `:` prefix.
# They are defined automatically by N7 on the remote hosts, but are only
# invoked at the end of all task runs if an event has been triggered.
N7_HANDLERS=()

# Maps a task name to its N7_TASK_IDX
declare -A N7_TASK_NAME_2_INDEX

# In case no LOCAL nor REMOTE task option is set for a task, this will
# be the default.
N7_DEFAULT_TASK_TYPE=${N7_DEFAULT_TASK_TYPE:-LOCAL}


# Each task can optionally have leading null commands that specifies task specific
# options. See the `N7::load_task_opts' function for the exact format.
# Known task options are:
N7_TASK_OPT_NAMES=(
  DESCRIPTION     # describe what the task does.
  TIMEOUT         # timeout in seconds for the remote task.
  NO_SUBSHELL     # set it to run the task directly in the N7 login shell.

  LOCAL           # set it to run the task locally.
  REMOTE          # set it to run the task remotely.

  #Note: If both LOCAL and REMOTE are set then the which ever is set
  #      later overrides the former; if neither LOCAL nor REMOTE is set
  #      then, the task is of the $N7_DEFAULT_TASK_TYPE, which defaults to
  #      LOCAL.

  IGNORE_STATUS   # set it to run the remaining tasks even if the task exited
                  # with a non-zero exit status. 
)
declare -r N7_TASK_OPT_NAMES

N7_TASK_TIMEOUT=${N7_TASK_TIMEOUT:-60}    # default task timeout, in seconds.
N7_ERRNO_TIMEOUT=999  # a task exits with this exit code if it's timed out.
declare -r N7_ERRNO_TIMEOUT
#Note: this is a special "exit code" since it's > 255 it won't be confused
#      with the task's exit code.

N7_EOT=$(openssl rand -hex 16) # "End Of Task" marker
#
# At the end of each a task execution, N7 outputs an EOT line of this form:
#
#   "$N7_EOT $host $N7_TASK_IDX $? changed"
#
# where $host is the hostname N7 used to ssh into the host, $N7_TASK_IDX is
# integral index of the task into the N7_TASKS array, and $? is  the exit
# status of the last command run by the task. 'changed' indicates whether
# the task has changed the state of the system, and if not, then it's should
# be a single '-' character instead of 'changed'. Within a task, an user
# can call the 'N7::remote::tasks::touch_changed' function to mark the task
# as changed the system state.
#

N7_DIR=${N7_DIR:-/tmp/n7} && mkdir -p "$N7_DIR"
N7_DIR=$(cd "${N7_DIR:-/tmp/n7}" && pwd)
N7_RUN_ID=$(printf "%d_%(%s)T" $$ -1)
N7_RUNS_DIR=$N7_DIR/runs
N7_RUN_DIR=$N7_RUNS_DIR/$N7_RUN_ID
declare -r N7_DIR N7_RUN_ID N7_RUNS_DIR N7_RUN_DIR


# used for temporarily storing updated N7_EHOSTS by a local task.
N7_EHOSTS_FILE=${N7_EHOSTS_FILE:-$N7_RUN_DIR/.ehosts}

# where stderr goes during N7 init or process clean up.
# mainly used to silence N7's init task outputs and 
# bash's child-process-got-killed message during process clean up.
N7_INTERNAL_ERR_FILE=$N7_RUN_DIR/.cleanup.err

# The command to run sudo. Options can be added too.
# Eg, N7_SUDO='sudo -u someone'
#
# This is mainly used by N7's built-in functions(eg, N7::local::files::cp()).
# It can also be overriden by the `sudo` option of the built-in functions
# that support it. In your own task you can just run sudo by yourself.
N7_SUDO=${N7_SUDO:-sudo}

# Where N7 store temporary file on a remote host.
N7_REMOTE_TMP_DIR=/var/tmp/n7
N7_REMOTE_RUN_DIR=$N7_REMOTE_TMP_DIR/$N7_RUN_ID

N7_SSH_OPTS=${N7_SSH_OPTS:-"
  -o BatchMode=yes
  -o PasswordAuthentication=no
  -o ControlMaster=auto
  -o ControlPersist=60s 
  -o ControlPath=$N7_DIR/tmp/n7-ssh-%h-%p-%r
"}
N7_SSH_CMD="ssh $(printf "%s " $N7_SSH_OPTS)"
N7_SSH_PPIDs=()
N7_SSH_PIPE_FDs=()  # file descriptors redirected to write to the SSH read pipes.
                    # these FDs exist mainly to keep the pipes open.

# stdout of the last ansible module executed.
N7_ANSIBLE_OUT=$N7_REMOTE_RUN_DIR/ansible.out
declare -r N7_ANSIBLE_OUT

# whether N7::cleanup has been called or not.
N7_CLEANING_UP=

# The shell to switch to once ssh to a remote host. Only Bash is supported.
N7_REMOTE_SHELL=/bin/bash
#
mkdir -p "$N7_DIR" "$N7_DIR/tmp" "$N7_RUNS_DIR" "$N7_RUN_DIR"
touch $N7_INTERNAL_ERR_FILE
#---------------------------------------------------------------



#--- Define the core functions that make up n7 -----------------

N7::close_ssh_pipes() {
    local fd pid_pgid host
    for fd in ${N7_SSH_PIPE_FDs[*]}; do
        eval "exec $fd>&-"
    done

    # Kill each of the whole process groups that's reading the ssh pipes.
    # Do it first with SIGTERM and then finally with SIGKILL.
    #
    local sig pids=$(ps x -opid,pgid | awk 'NR==1 {next}; {printf("%d,%d\n", $1, $2)}')
#    for sig in TERM KILL; do
    for sig in TERM; do
        for pid_pgid in $pids; do
            if [[ " ${N7_SSH_PPIDs[*]} " =~ " ${pid_pgid%,*} " ]]; then
                kill -$sig -- -${pid_pgid#*,} >/dev/null 2>&1 || true
            fi
        done
    done

    for host in $N7_HOSTS; do
        rm -f "$(N7::ssh_read_pipe $host)"
    done
}


N7::cleanup() {
    local last_rc=$?

    # To prevent from being called more than once.(eg, from ERR and EXIT)
    if ! mv "$N7_INTERNAL_ERR_FILE" \
          "$N7_INTERNAL_ERR_FILE.done" >/dev/null 2>&1; then
        return
    fi

    if [[ $last_rc -ne 0 ]]; then
        set +x; N7::print_stack_trace
    fi

    set +e +E

    # this is to silence bash from reporting to stderr that a
    # child process was killed with SIGKILL.
    exec 2>>"$N7_INTERNAL_ERR_FILE.done"
    
    N7::close_ssh_pipes
    rm -f "$N7_EHOSTS_FILE"
    if [[ ! $N7_KEEP_RUN_DIR ]]; then
        rm -rf "$N7_RUN_DIR"
    fi
    exit $last_rc
}

N7::ssh_read_pipe() { echo "$N7_RUN_DIR/$1.pipe_r"; }
N7::ssh_out_file() { echo "$N7_RUN_DIR/$1.out"; }
N7::ssh_err_file() { echo "$N7_RUN_DIR/$1.err"; }
N7::ssh_host_from_out_file() { echo $(basename "${1%.out}"); }
N7::send_cmd() { printf "%s\n" "$1" >"$(N7::ssh_read_pipe ${2:?'Empty host!'})"; }

N7::send_eot_line() {
    local last_builtin_task_idx=$((${#N7_BUILTIN_TASKS[*]} - 1))

    # the line is: <eot_hash> <hostname> <task_index|-1> <exit_status|$?> <changed|->
    local line="$N7_EOT $1 ${N7_TASK_IDX:-$last_builtin_task_idx} ${2:-\$N7_RC} \
               \$([ -e \"\$(N7::remote::tasks::change_file)\" ] && echo changed || echo -)"

    N7::send_cmd "N7_RC=\$?; (echo; echo $line) | tee /dev/stderr" ${1:?'Empty host!'}
    #
    # NOTE: we always output a newline before sending the EOT line so
    #       that the EOT line will always be on its own line.
}

N7::ssh_ehosts() {
    if [[ -r $N7_EHOSTS_FILE ]]; then
        N7_EHOSTS=$(<"$N7_EHOSTS_FILE") 2>/dev/null
        rm -f "$N7_EHOSTS_FILE"
    fi
    echo $N7_EHOSTS
}


# Output a list of function names matching a specific pattern in the order
# they are defined in $N7_SCRIPT.
#
N7::_get_func_names() {
    local f line p
    for f in $(declare -f | grep -- "$1" | cut -d' ' -f1); do
        line=$(declare -F $f)
        p=${line#* }; p=${p#* }
        if [[ $p = $N7_SCRIPT ]]; then printf "%s\n" "$line"; fi
    done | sort -nk2 | cut -d' ' -f1
}


# N7::load_tasks
#
# Load up N7_TASKS with task names in the order they are defined in N7_SCRIPT.
#
# The task indexes are layed out in this order(just an example):
#
#    0    1    2    3    4    5    6    7    8    9   10   11   12  13...
#    <built-in task names...> <user-defined task names...> <handler names...>
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^
#                 \________ defined in N7_TASKS                \___ defined in N7_HANDLERS
#
#    (<built-in task names...> are also defined in N7_BUILTIN_TASKS)
#
# Thus, the first built-in task will have task index 0, and the first
# user-defined task will have the task index ${#N7_BUILTIN_TASKS[*]}, and
# the handlers, although not added to N7_TASKS, will have the first task
# index starting from ${#N7_TASKS[*]}
#
N7::load_tasks() {
    # Add built-in tasks
    N7_TASKS+=(${N7_BUILTIN_TASKS[*]})

    # Add command-line tasks
    N7_TASKS+=($(declare -f | grep "^\.N7::cli_task::" | cut -d' ' -f1 | sort -t: -nk5))
    #FIXME: .N7::cli_task:: is a hard coded prefix that's also used in globals.part and
    #        show_task_outputs().

    shopt -s extdebug
    N7_TASKS+=($(N7::_get_func_names '^\.'))
    N7_HANDLERS+=($(N7::_get_func_names '^:'))
    shopt -u extdebug
    if [[ ${#N7_TASKS[*]} -le ${#N7_BUILTIN_TASKS[*]} ]]; then
        N7::log "No tasks are defined!" WARNING
    fi

    # Create the reverse, task name -> task index map.
    local task i=0
    for task in ${N7_TASKS[*]} ${N7_HANDLERS[*]}; do
        N7_TASK_NAME_2_INDEX[$task]=$((i++))
    done

    N7::load_task_opts ${N7_TASKS[*]} ${N7_HANDLERS[*]}
}

# N7::parse_task_opts <task_defn>
#
# Take a function definition, parse all leading null commands(:) of the form:
#
#     ': name1=value1'
#     ': name2=value2'
# 
# until the first non-null command, which marks the end of the task option section.
#
# Output the right hand side of an associative array assignment of this form:
#
#     '(
#      [name1]=value1
#      [name2]=value2
#        ...
#      )'
#
N7::parse_task_opts() {
    local section=$(awk '/^ *: /, $0 ~ "^ *[^#]" && $0 !~ "^ *: " {print}' <<<"$(declare -f $1)")
    echo "("
    echo "$section" | sed '$d
      s/^ *:  *//g 
      s/\([^ ]\)/\[\1/ 
      s/=/\]=/
      s/;$//
    '
    echo ")"
}

# Usage: N7::get_task_opt <task_idx> <opt_name>
N7::get_task_opt() {
    local task_opt="N7_TASK_OPTS_$1[$2]"
    printf "%s\n" "${!task_opt}"  
}

# N7::load_task_opts <all task definitions...>
#
# Dynamically assign a global array variable, N7_TASK_OPTS_{n}.
#
# So as an example, for the first task(task 0) you have N7_TASK_OPTS_0.
# The options in such array can be obtained via the `N7::get_task_opt' function.
#
N7::load_task_opts() {
    local task_idx=-1 task task_opts name val
    while (( $# > 0 )); do
        name=N7_TASK_OPTS_$((++task_idx))
        task=$1; shift
        task_opts=$(N7::parse_task_opts "$task")

        declare -gA "$name=$task_opts"

        # check if each option name is valid by removing all known option
        # names from an array of user specified option names.
        val=($(eval echo '${!'$name'[*]}'))
        for name in ${N7_TASK_OPT_NAMES[*]}; do # 
            val=(${val[*]/#$name})
        done

        # if there's still any options left over then it's an unknown option.
        if [[ $(printf %s "${val[*]}") ]]; then
            N7::die "Invalid task options(${val[*]}) in task #$task_idx"
        fi
        
        # validate the TIMEOUT value
        val=$(N7::get_task_opt $task_idx TIMEOUT)
        [[ ! $val || $val -gt 0 ]] || N7::die "Invalid timeout(\`$val') for task #$task_idx!"

        # set NAME to function name if it's not specified.
        if [[ ! $(eval echo \${N7_TASK_OPTS_$task_idx[NAME]}) ]]; then
            declare -g "N7_TASK_OPTS_$task_idx[NAME]=$task"
        fi

        # deal with LOCAL and REMOTE
        local localremote=$(echo "$task_opts" | grep -P '^\[LOCAL|REMOTE\]=' | tail -n1)
        val=N7_TASK_OPTS_$task_idx
        if [[ ! $localremote ]]; then
            declare -g "$val[$N7_DEFAULT_TASK_TYPE]=1"
        elif [[ $localremote  == \[LOCAL\]=* ]]; then
            unset $val[REMOTE]
        elif [[ $localremote  == \[REMOTE\]=* ]]; then
            unset $val[LOCAL]
        fi
    done
}


# N7::wait_for_tasks_on_hosts <task_idx> [host1 host2 ...]
#
# Periodically look at the last line of each host out-file, expecting the EOT marker.
#
# If the EOT line is found at the end within task timeout, then it means the last
# task has finished. Otherwise, the task has been timed out.
#
# Output the EOT lines. For timed out hosts, the rc field of the EOT line will be
# set to $N7_ERRNO_TIMEOUT.
#
N7::wait_for_task_on_hosts() {
    local task_idx=$1; shift
    local timeout=$(N7::get_task_opt $task_idx TIMEOUT)
    local out_files=$(for h in $*; do N7::ssh_out_file $h; done)
    # NOTE: $out_files is a newline separated string of pathes.
    #       The use of IFS=$'\n' below is to make word-splitting split on
    #       newlines instead of white spaces, because a path may contain spaces.

    local eot_lines

    timeout=${timeout:-$N7_TASK_TIMEOUT}
    SECONDS=0
    while (( SECONDS < timeout )); do
        sleep 0.01
        eot_lines=$(IFS=$'\n' 
            tail -v -n1 $out_files |  # with tail's '==> path <==' headers
            grep -aPB1 "^$N7_EOT [^ ]+ \b$task_idx\b \d+" || true
        )

        if [[ $eot_lines ]]; then grep "^$N7_EOT" <<<"$eot_lines"; fi
        out_files=$(
            diff <(echo "$eot_lines" | grep "^==>" | cut -d' ' -f2 | sort) \
                 <(echo "$out_files" | sort) | grep '^>' | cut -d' ' -f2
        )
        if [[ ! $out_files ]]; then return; fi  # ie, all out files have the EOT at the end.

    done
    local path oIFS=$IFS
    IFS=$'\n'
    for path in $out_files; do
        echo "$N7_EOT $(N7::ssh_host_from_out_file "$path") $task_idx $N7_ERRNO_TIMEOUT"
    done
    IFS=$oIFS
}

# N7::wait_for_task <task_idx> [host1 host2 ...]
#
# Wait for task to finish running until a timeout on each host.
# Outputs a string of hosts that N7 will be using for running the next task.
#
N7::wait_for_task() {
    local task_idx=$1; shift
    local ignore_status=$(N7::get_task_opt $task_idx IGNORE_STATUS)
    local hosts=$*
    local host rc

    # wait for the EOT marker at the end in each host's out file
    while read -r _ host _ rc _; do

        if [[ $rc != 0 ]]; then

            # remove timed out host so that it won't block the next task
            if [[ $rc = $N7_ERRNO_TIMEOUT ]]; then
                hosts=$(echo ${hosts/$host})

            # remove failed host if the task has no IGNORE_STATUS set
            elif [[ ! $ignore_status ]]; then
                hosts=$(echo ${hosts/$host})
            fi
        fi
        #NOTE: if a task is timed out but has IGNORE_STATUS set, and
        #  is actually still executing, it will block the tasks after
        #  it(because all tasks for a host share one ssh pipe), thus
        #  its following tasks are likely also going to be timed out.
    done < <(N7::wait_for_task_on_hosts $task_idx $hosts)
    echo $hosts
}


# N7::ssh_connect [host1 host2 ...]
#
# Establish ssh connections to remote hosts and setup named pipes and
# I/O redirects for N7 to communicate with the ssh processes and to
# recieve task outputs.
#
N7::ssh_connect() {
    local host port ssh_pipe ssh_out ssh_err fd
    for host in $*; do
        ssh_pipe=$(N7::ssh_read_pipe $host)
        if [[ -e $ssh_pipe ]]; then
            continue
        fi
        N7::debug "Creating pipes for $host..."
        ssh_out=$(N7::ssh_out_file $host) && touch "$ssh_out" && chmod 0600 "$ssh_out"
        ssh_err=$(N7::ssh_err_file $host) && touch "$ssh_err" && chmod 0600 "$ssh_err"

        mkfifo -m600 "$ssh_pipe" || N7::die "Failed making named pipes for ssh!"

        port=${N7_HOST_PORTS[$host]#:}

        N7::debug "Connecting to $host..."
        N7::debug "$N7_SSH_CMD ${port:+-p$port} $host"

        set -m  # temporarily enable job control to create the following
        (       # subshell in its own process group.
          $N7_SSH_CMD ${port:+-p$port} $host "exec -l $N7_REMOTE_SHELL" <"$ssh_pipe" >"$ssh_out" 2>"$ssh_err"
          if [[ $? -gt 0 && $? -lt 128 ]]; then
              N7::log "$(echo "SSH connection to $host disconnected!"; cat "$ssh_err")"
          fi

          # make any further writes to the pipe fail without blocking,
          # then read from the pipe to unblock the process that had written
          # to it before the chmod.
          chmod a-w "$ssh_pipe" &&
          while true; do cat "$ssh_pipe" >/dev/null; done || true #FIXME: don't discard the data read?

        ) 2>>"$N7_INTERNAL_ERR_FILE" &
        set +m
        N7_SSH_PPIDs+=($!)

        N7::debug "SSH ppid=${N7_SSH_PPIDs[-1]} for $host"

        # this is just to keep the pipe from being closed when its
        # write end closes.
        exec {fd}>"$ssh_pipe" || N7::die "Failed FD creations and redirections"
        N7_SSH_PIPE_FDs+=($fd)
    done
}

# N7::show_task_outputs <task_idx> <hosts>
#
# Print the stdout of the task specified by the task index if the task is a
# command-line task or if the -o command-line option is set.
#
# Standard output of local tasks are always shown unless redirected within the
# local tasks.
#
# Further more, only the outputs delimited by the last EOT line are shown in
# cases where a task produces multiple EOT lines.
#
N7::show_task_outputs() {
    local task_idx=$1; shift
    local task_name=${N7_TASKS[$task_idx]}
    local last_task_idx=$((task_idx - 1))

    local show_output
    if [[ $N7_TASK_SHOW_STDOUT ||
          ${task_name/#.N7::cli_task::} != $task_name ]]; then
        show_output=1
    fi

    local host from_line out_file
    for host in $*; do
        out_file=$(N7::ssh_out_file $host)

        if [[ $show_output ]]; then
            from_line=$(grep -an "^$N7_EOT $host $last_task_idx " "$out_file" |
                    tail -n1 | cut -d: -f1)
            let ++from_line
            tail -n+$from_line "$out_file"
            #
            #NOTE: when outputing stdout, we are not removing the EOT line nor the
            #      empty line before it because even though those are not send by
            #      the user, removing them risk removing user output in the case
            #      of timeout.
            #
            # The N7::local::tasks::get_stdout() won't output the EOT line, and
            # using $(...) with the function usually gives the desired result
            # because bash always remove trailing newlines from a command
            # substitution.
        else
            local rc_change=$(grep -a "^$N7_EOT $host $task_idx" "$out_file" | tail -n1 | cut -d' ' -f4,5)
            N7::log "$host rc=${rc_change% *} state=${rc_change#* }"
        fi
    done
}

# N7::run_tasks <"task_name1 task_name2 ..."> <"host1 host2 ...">
# 
# Execute the bash functions(tasks) named on all the hosts specified.
# Each task will be run on all hosts, and a task must finish its execution on all hosts
# before the next will be run. If a task execution fails or timed out on a host then
# that host will be removed from execution of any further tasks unless the task has
# its IGNORE_STATUS option set and is not timed out.
#
# Moreover, the following environment variables will be available to all tasks:
#
#   N7_TASK_IDX - The index number(0-based) of the current task.
#   N7_EHOSTS   - "The effective hosts". A space separated list of hosts that the
#                 current task is going through.
#   N7_HOST     - The host on which the current task is running.
#
N7::run_tasks() {
    N7_EHOSTS=$(echo $2)

    # export it so this will be available to local tasks.
    local N7_TASK_IDX; export N7_TASK_IDX

    set -- $1

    N7::ssh_connect $N7_EHOSTS

    local host task rc no_subshell sudo

    while [[ $# -gt 0 && $N7_EHOSTS ]]; do
        task=$1; shift
        N7_TASK_IDX=${N7_TASK_NAME_2_INDEX[$task]}

        no_subshell=$(N7::get_task_opt $N7_TASK_IDX NO_SUBSHELL)

        N7::log "Running Task: $(N7::get_task_opt $N7_TASK_IDX NAME) ..."

        # handle local task, which has no timeout control.
        if [[ $(N7::get_task_opt $N7_TASK_IDX LOCAL) ]]; then
            export N7_HOST=localhost;

            if [[ $no_subshell ]]; then $task; else ($task); fi; rc=$?
            N7::log "localhost rc=$rc"

            if [[ $rc != 0 && ! $(N7::get_task_opt $N7_TASK_IDX IGNORE_STATUS) ]]; then
                N7::die "Error running local task #$N7_TASK_IDX: $(N7::get_task_opt $N7_TASK_IDX NAME)"
            fi

            # the local task might invoke a function that changes N7_EHOSTS in a subshell
            # this updates the global N7_EHOSTS var from N7_EHOSTS_FILE.
            N7::ssh_ehosts >/dev/null

            # We also send an EOT line to each remote host at the end of a local task.
            # This is to make extracting stdout or stderr of a remote task easier.
            for host in $N7_EHOSTS; do N7::send_eot_line $host $rc; done

        else
            # send the remote task to each host
            for host in $N7_EHOSTS; do
                N7::run_pre_task_function $task $host
                N7::send_cmd " \
                    export N7_TASK_IDX=$N7_TASK_IDX \
                           N7_EHOSTS=\$(echo $N7_EHOSTS) \
                           N7_HOST=$(N7::q "$host") \
                    " $host
                [[ $no_subshell ]] || N7::send_cmd '('             $host
                                      N7::send_cmd $task           $host
                [[ $no_subshell ]] || N7::send_cmd ') </dev/null'  $host
                N7::send_eot_line $host
            done
            N7_EHOSTS=$(N7::wait_for_task $N7_TASK_IDX $N7_EHOSTS)
        fi

        #FIXME: this doesn't show failed task output because failed
        #       hosts will have been removed from N7_EHOSTS
        N7::show_task_outputs $N7_TASK_IDX $N7_EHOSTS
    done
}

# 
# N7::run_pre_task_function <task_name> <hostname>
#
# Every remote task is allowed to have a pre-task function, which
# will be executed locally before the remote task is run.
#
# Such function will be passed the hostname, on which the remote
# task will be run as its first argument.
#
# One use of such function is to obtain, via the N7::local::tasks:get_stdout
# function, the stdout of the last remote task run on the same host, and then
# do something immediately.
#
N7::run_pre_task_function() {
    local fname=pre:$1
    local host=$2
    if declare -f $fname; then
 #FIXME: need to make sure the function is defined in the same source file, 
 #       in which the remote task is defined.
        $fname $host
    fi
}


#N7::run_tasks_on_hosts "tasks..." "hosts..."
#
N7::run_tasks_on_hosts() {
    local tasks=$1 hosts=$2
    if [[ $N7_SSH_COUNT ]]; then
        while read hosts; do
            N7::run_tasks "$tasks" "${hosts}"
            if [[ $(N7::ssh_ehosts) != $hosts ]]; then
                return $?
            fi
        done < <(tr ' ' '\n' <<<$hosts | paste -d' ' $(seq -f - ${N7_SSH_COUNT}))
    else
        N7::run_tasks "$tasks" "$hosts"
        [[ $(N7::ssh_ehosts) = $hosts ]]
    fi
}


#
trap 'N7::cleanup' ABRT ERR TERM QUIT INT EXIT HUP
# NOTE: N7::cleanup also calls N7::print_stack_trace on ERR.
#---------------------------------------------------------------


#--- Define built-in tasks to initialize environments and define
#    built-in functions on remote hosts.
#
# This is the very first local task that gets run by N7 to bootstrap remote
# tasks, and environment variables.
#
.N7::init_local() { : LOCAL=1
    # define remote tasks on remote hosts
    local task i=0

    for task in ${N7_TASKS[*]} ${N7_HANDLERS[*]}; do
        if [ "$(N7::get_task_opt $i REMOTE)" ]; then
            N7::local::commands::send_funcs $task
        fi
        i=$((++i))
    done
    # NOTE: implementation-wise, handlers are treated just like a task.
    N7::local::commands::send_env  \
        N7_SUDO=$(N7::q "$N7_SUDO") \
        N7_REMOTE_RUN_DIR=$(N7::q "$N7_REMOTE_RUN_DIR") \
        N7_REMOTE_TMP_DIR=$(N7::q "$N7_REMOTE_TMP_DIR") \
        N7_ANSIBLE_OUT=$(N7::q "$N7_ANSIBLE_OUT")
}

# This is the first remote task run by N7 to setup remote N7 built-ins
#
.N7::init_remote() {
    : REMOTE=1
    : NO_SUBSHELL=1

    # create N7 runtime directories
    mkdir -p "$N7_REMOTE_RUN_DIR" "$N7_REMOTE_TMP_DIR"
}

.N7::define_remote_builtins() {
    : REMOTE=1
    : NO_SUBSHELL=1

N7::q() { printf "%q\n" "$*"; }
N7::qm() {
    local result=$(printf "%q " "$@")
    printf "%s\n" "${result% }"
}
N7::get_sudo() {
    local sudo=${1:-$N7_SUDO}
    if [ "$sudo" = 1 ]; then echo "$N7_SUDO"; else echo "$sudo"; fi
}


# Functions under the N7::remote "namespace can be used both remotely and locally.

#
# Set file attributes. Options are:
#
#   owner  - owner name.
#   group  - group name.
#   mode   - file permission mode; only numeric octal digits allowed.
#
# Environment vars that affect the command:
#
#   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
#            value to use as the command to sudo.
#
# This function can be use both remotely and locally.
#
N7::remote::files::file() {
    local path=$(N7::q "$1")
    declare -A params=()
    local nv
    for nv in "$@"; do
        [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
    done
    local changed
    changed=$(${sudo:+$(N7::get_sudo "$sudo")} /bin/bash -s -- <<EOF
        owner=$(N7::q "${params[owner]}")
        group=$(N7::q "${params[group]}")
        mode=$(N7::q "${params[mode]}")
        mode=\${mode:-0\$(printf %o \$((0666 - \$(umask))))}
        if [[ \${#mode} = 3 ]]; then mode=0\$mode; fi
        rt=0; chgd=0
        read u g m < <(stat -c "%U %G %a" $path); if [[ \${#m} = 3 ]]; then m=0\$m; fi
        if [[ \$owner ]]; then [[ \$u == \$owner ]] || { chown \$owner $path && chgd=1; rt=\$((\$? | rt)); }; fi
        if [[ \$group ]]; then [[ \$g == \$group ]] || { chgrp \$group $path && chgd=1; rt=\$((\$? | rt)); }; fi
        if [[ \$mode  ]]; then [[ \$m == \$mode  ]] || { chmod \$mode  $path && chgd=1; rt=\$((\$? | rt)); }; fi
        echo \$chgd
        exit \$rt
EOF
    )
    local rc=$?; if [ "$changed" = 1 ]; then N7::remote::tasks::touch_change; fi
    return $rc
}


N7::remote::tasks::change_file() {
    local task_idx=${1:-$N7_TASK_IDX}
    if [ "$N7_HOST" != "localhost" ]; then
        echo "$N7_REMOTE_RUN_DIR/task_$task_idx.change"
    else
        echo "$N7_RUN_DIR/task_$task_idx.change"
    fi
}
N7::remote::tasks::touch_change() {
    local change_file=$(N7::remote::tasks::change_file)
    [ -e "$change_file" ] || touch "$change_file"
}
N7::remote::tasks::reset_change() {
    rm -f "$(N7::remote::tasks::change_file)"
}
N7::remote::tasks::changed() {
    [ -e "$(N7::remote::tasks::change_file $1)" ]
}


# N7::remote::ansible::check_status
#
# Check the exit status of the last Ansible module run.
# Return 1 if it the run failed; return 0 otherwise.
#
N7::remote::ansible::check_status() {
    local changed
    changed=$(python -c '
import sys, json
#FIXME: handle single line name=value pairs
with open(sys.argv[1]) as f:
    data = json.load(f)
if data.get("changed"):
    print 1
if "failed" in data:
    sys.exit(1)
'    "$N7_ANSIBLE_OUT"
    )
    local rc=$?
    if [ "$changed" = 1 ]; then N7::remote::tasks::touch_change; fi
    return $rc
}

}



#
#--- Define local-only built-in functions -----------------------
#
# Functions under the N7::local "namespace" can only be used locally.

N7::local::ansible::replace_mod() {
    python - <<<"$(cat <<'EOF'
#
# Tested with Ansible 1.4.4
#
# Usage: $0 <module_name> [name=value ...]
#
# If the last argument is a single '-' character then also
# read complex args(ie, YAML) from stdin.
#
# Outputs:
#   First line is the module style: 'new' or not 'new'.
#   The rest is the modified ansible module to be transferred to remote hosts.
#
# Note that if module style is not 'new' then you have to provide the arguments
# as stdin to the module when you execute it, and in this case, I believe,
# complex args is not supported.
#

import sys
import yaml

import ansible.utils
import ansible.errors
from ansible.module_common import ModuleReplacer

replacer = ModuleReplacer(True)

mod_name = sys.argv[1]
mod_src = ansible.utils.module_finder.find_plugin(mod_name)
if not mod_src:
    raise ansible.errors.AnsibleFileNotFound("module %s not found in %s" % (
        mod_name, ansible.utils.plugins.module_finder.print_paths()))

complex_args = {}

# if the last arg is a '-' then read stdin as complex args.
if sys.argv[-1] == '-': 
    complex_args = yaml.load(sys.stdin)
    del sys.argv[-1]

mod_args = ' '.join(sys.argv[2:])

inject = {}
mod_dump, mod_style, shebang = replacer.modify_module(mod_src, complex_args, mod_args, inject)

print mod_style
print mod_dump

EOF
)" "$@"
}


# N7::local::ansible::send_mod <module_name> [name=value ...]
#
# Transfer an ansible module over to the remote hosts.
# The ansible module will be configured with the arguments specified if
# it's a new style module.
# 
N7::local::ansible::send_mod() {
    local data
    data=$(N7::local::ansible::replace_mod "$@") || return $?
    echo "$data" | (
        read mod_style
        tmpf=$N7_REMOTE_RUN_DIR/ansmod_${mod_style}.$(openssl rand -hex 16)
        echo $tmpf
        N7::local::files::cp <(cat) "$tmpf" mode=0755
    )
}


# N7::local::ansible::run_mod <module_name> [name=value ...]
#   
# Transfer and run an ansible module with the specified arguments.
#
# Environment vars that affect the command:
#
#   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
#            value to use as the command to sudo.
#
N7::local::ansible::run_mod() {
    local tmpf; tmpf=$(N7::local::ansible::send_mod "$@") || return 1
    local mod_style=$(basename "${tmpf%%.*}"); mod_style=${mod_style#ansmod_}

    if [[ $mod_style = new ]]; then
        N7::local::commands::remote "
            ${sudo:+$(N7::get_sudo "$sudo")} $tmpf | tee \$N7_ANSIBLE_OUT
            rm -f $tmpf
            N7::remote::tasks::reset_change
            N7::remote::ansible::check_status
        "
    else
        N7::local::commands::remote "
            ${sudo:+$(N7::get_sudo "$sudo")} $tmpf <<<$(N7::q $*) | tee \$N7_ANSIBLE_OUT
            rm -f $tmpf
            N7::remote::tasks::reset_change
            N7::remote::ansible::check_status
        "
    fi
}


#
# Wrapper around Bash's built-in trap command.
# It takes care not to overwrite existing commands already assigned to a signal.
#
# Use it instead if you would like to use trap in your N7 script.
#
N7::local::utils::trap() {
    local cmd=$1; shift
    local signal cur_cmd;
    for signal in $*; do
        cur_cmd=$(trap -p $signal)
        cur_cmd=${cur_cmd#*\'}
        cur_cmd=${cur_cmd%\'*}
        trap "${cur_cmd:+"$cur_cmd;"} $cmd" $signal
    done
}


# N7::local::commands::remote <cmd>
#
# Run cmd on ALL effective remote hosts.
# The command will be run in a subshell unless the env var no_subshell is
# set for the command. Eg, no_subshell=1 N7::local::commands::remote "echo hello"
#
# Return 0 if the command was run successfully on all remote hosts;
# return 1 otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::remote() {
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        [ "$no_subshell" ] || N7::send_cmd '(' $host
        N7::send_cmd "$1"                      $host
        [ "$no_subshell" ] || N7::send_cmd ')' $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::commands::send_funcs [func_name1 func_name2 ...]
#
# Define the list of functions specified on the remote end.
# Abort n7 with an error if it can't locate all functions specified.
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 otherwise.
#
# Alternatively, you can define your remote helper functions within
# a remote task function that declares ': NO_SUBSHELL=1' so that when
# the task is run remotely, all the functions within it will be defined
# globally for later tasks.
#
# This function can only be used from a local task.
#
N7::local::commands::send_funcs() {
    local name funcs=() failed=()
    for name in $*; do
        funcs+=("$(declare -f "$name")") || failed+=("$name")
    done
    [ "$failed" ] && N7::die "Failed locating functions: ${failed[*]}"

    local f hosts=$(N7::ssh_ehosts)
    for f in "${funcs[@]}"; do
        no_subshell=1 N7::local::commands::remote "$f"
    done
    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::commands::send_env [name1=value1 name2=value2 ...]
#
# Define environment variables on all remote hosts.
#
# Each name=value pair must be passed to this function as a single argument.
# (i.e., space and special shell characters will need to be quoted)
#
# Return 0 if all functions are defined successfully on the remote hosts;
# return 1 otherwise.
#
# This function can only be used from a local task.
#
N7::local::commands::send_env() {
    local host name_value hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        for name_value in "$@"; do
            N7::send_cmd "export $(N7::q "$name_value") &&" $host
        done
        N7::send_cmd "true" $host
        N7::send_eot_line $host
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::commands::n7 -s <n7script_path> [options] [args]
#
# Run n7 in a subshell with the current effective hosts.
#
# The current effective hosts will be passed to the n7 subprocess, therefore
# you should not specify the -m option.
#
N7::local::commands::n7() {
    echo $N7_EHOSTS | N7_EHOSTS_FILE=$N7_EHOSTS_FILE "$0" -m - "$@"
}


# N7::local::files::cp <local_path> <remote_path> [options]
#
# Copy a file from localhost to the remote hosts.
# Any host it fails to copy the file to will be removed from $N7_EHOSTS.
# Return 0 if the file is copied to all hosts successfully; return 1 otherwise.
#
# Options are name=value pairs. Quotes are needed to escape space and other
# special characters.
#
# Options:
#
#   tplcmd - template command to run to process <local_path> before sending it
#            to a remote host.
#
#            Environment variables available to the invoking local task will
#            still be availalbe, plus a N7_HOST env var will be set to the
#            remote host that the file will be copied to.
#
#            N7 includes a built-in N7::local::files::bash_tpl function, which 
#            will process the file as a here-doc.
#
# All options allowed by the N7::remote::files::file task are also allowed here.
# 
# Environment vars that affect the command:
#
#   sudo   - sudo before the operation. 1 to use $N7_SUDO, any other
#            value to use as the command to sudo.
#
# This function can only be used from a local task one at a time. 
#
N7::local::files::cp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
    done
    local tplcmd=${params[tplcmd]}
    local _sudo=${sudo:+$(N7::get_sudo "$sudo")}

    local token=$(openssl rand -hex 8)
    N7::local::commands::remote "echo $token \$($_sudo openssl md5 -r $(N7::q "$dest") 2>/dev/null | cut -d' ' -f1)"

    local host hosts=$(N7::ssh_ehosts)
    local lmd5 rmd5 encoded content

    if [ "$tplcmd" ]; then
        for host in $hosts; do
            content=$(N7_HOST=$host $tplcmd "$src") || return $?
            lmd5=$(openssl md5 -r <<<"$content" | cut -d' ' -f1)
            rmd5=$(N7::local::tasks::get_stdout $host $N7_TASK_IDX $token); rmd5=${rmd5#* }

            # only copy the file if their md5 sums differ
            if [ "$rmd5" != "$lmd5" ]; then
                encoded=$(base64 <<<"$content") || return $?
                N7::send_cmd "unset N7_RC; echo \"$encoded\" | base64 --decode |
                    $_sudo tee $dest >/dev/null && N7::remote::tasks::touch_change; N7_RC=\$?" $host
            fi
            N7::send_cmd "sudo=$(N7::q "$sudo") N7::remote::files::file $dest $(N7::qm "$@")" $host
            N7::send_eot_line $host '$(( N7_RC | $? ))'
        done
    else
        content=$(<"$src") || return $?
        lmd5=$(openssl md5 -r <<<"$content" | cut -d' ' -f1)
        encoded=$(base64 <<<"$content") || return $?

        for host in $hosts; do
            rmd5=$(N7::local::tasks::get_stdout $host $N7_TASK_IDX $token); rmd5=${rmd5#* }

            # only copy the file if their md5 sums differ
            if [ "$rmd5" != "$lmd5" ]; then
                N7::send_cmd "unset N7_RC; echo \"$encoded\" | base64 --decode |
                    $_sudo tee $dest >/dev/null && N7::remote::tasks::touch_change; N7_RC=\$?" $host
            fi
            N7::send_cmd "sudo=$(N7::q "$sudo") N7::remote::files::file $dest $(N7::qm "$@")" $host
            N7::send_eot_line $host '$(( N7_RC | $? ))'
        done
    fi

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::files::bash_tpl <bash_template_file_path>
#
# Print the contents of a local file to stdout.
# The file content is subject to parameter expansions and process substitutions.
#
# Output lines(with optional leading space characters) that begin with the
# character sequence #: will be removed from the output. 
#
# In cases where variable assignment is needed, parameter expansion
# can be used to achieve the desired side effect.
#
# Example template file:
#
#    #: ${time_start:=$(date +%s)}
#    Sleeping...
#    #: $(sleep 2)
#    Slept for $(($(date +%s) - time_start)) seconds.
#
# Note that time_start must not have been set in order for it to be
# set, and once it's set, it cannot be unset or re-assigned. So, rather
# this trick is more like "binding" a var name to a value than setting
# a variable to a value.
#
N7::local::files::bash_tpl() {
    (
        source <(echo "cat <<EOF
$(<"$1")
EOF
"       )
    ) | sed '/^[[:space:]]*#:.*$/d'
}


#
# This is an alternative implementation of N7::local::files::cp() that uses scp
# instead. It first scp the source file to a temporary file and then move it over
# to the destination if the scp was successful. It might be faster and safer for
# large files.
#
N7::local::files::scp() {
    local src=$1 dest=$(N7::q "$2"); shift; shift
    local -A params=()
    local nv; for nv in "$@"; do
        [[ $nv =~ .+= ]] && params[${nv%%=*}]=${nv#*=}
    done

    local tmpdir=$(N7::q "$N7_REMOTE_TMP_DIR")
    local host hosts=$(N7::ssh_ehosts)
    for host in $hosts; do
        N7::send_cmd "tmpdir=$tmpdir mktemp -t .tmp.XXXXXXXXXXX" $host
        #FIXME: tmp file name shows up in stdout...
        N7::send_eot_line $host \$?
    done
    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)

    local tmpf pids=()
    local -A tmpfiles=()
    for host in $hosts; do
        tmpf=$(N7::local::tasks::get_stdout $host $N7_TASK_IDX | tail -2 | head -1)
        tmpfiles[$host]="$tmpf"
        scp $N7_SSH_OPTS "$src" "$host:$tmpf" &
        pids+=($host,$!)
    done

    local _sudo=${sudo:+$(N7::get_sudo "$sudo")}

    local host_pid 
    for host_pid in ${pids[*]}; do
        host=${host_pid%,*}
        src=$(N7::q "${tmpfiles[$host]}")
        N7::send_cmd ": N7::local::files::scp $src $dest" $host
        if wait ${host_pid#*,}; then
            N7::send_cmd "
                $_sudo mv $src $dest &&
                sudo="$sudo" N7::remote::files::file $dest $(N7::qm "$@")
            " $host
            N7::send_eot_line $host \$?
        else
            N7::send_eot_line $host 1
        fi
    done

    hosts=$(N7::wait_for_task $N7_TASK_IDX $hosts)
    echo $hosts >"$N7_EHOSTS_FILE"

    [ "$N7_EHOSTS" = "$hosts" ]
    return $?
}


# N7::local::tasks::get_stdout <hostname> <task_index|task_name> [pattern]
#
# Output the stdout of the task with <task_idx> from <hostname> that
# matches the optional regex pattern.
#
N7::local::tasks::get_stdout() {
    local task_idx
    if ! N7::is_num "$2"; then
        task_idx=${N7_TASK_NAME_2_INDEX[$2]}
    else
        task_idx=$2
    fi
    [ "$task_idx" -ge 0 ] &&
    awk 'BEGIN { i = 0 }
    { if ($0 !~ "^'$N7_EOT'") {
        if ($0 ~ /'${3:-.}'/)
          lines[i++] = $0
      } else {
        if ($3 == "'$task_idx'")
          for (e=0; e < i; e++)
            print lines[e];
        i=0;
      } 
    }' "$(N7::ssh_out_file $1)"
}

#
# Output the stderr of the task with <task_idx> from <hostname>
#
eval "$(declare -f N7::local::tasks::get_stdout \
         | sed -e 's/stdout/stderr/
                   s/_out_/_err_/'
       )"

#
# This remote task defines N7's remote built-in functions.
# It is run here so that those functions will also be available
# locally as well.
.N7::define_remote_builtins
#
#----------------------------------------------------------------

#--- Load shorthands for builtin functions ----------------------
#
n7_ansmod=N7::local::ansible::run_mod

n7_cp=N7::local::files::cp
_n7_cp_tpl() { $n7_cp "$@" tplcmd=N7::local::files::bash_tpl; }
n7_cp_tpl=_n7_cp_tpl

n7_remote=N7::local::commands::remote
n7_remote_output=N7::local::tasks::get_stdout
n7_file=N7::remote::files::file
#
#----------------------------------------------------------------

# Load user's .n7 script
if [[ $N7_SCRIPT ]]; then
    source "$N7_SCRIPT" "${N7_SCRIPT_ARGS[@]}" || N7::die "Failed loading $N7_SCRIPT!"
fi

# We've given the .n7 script the chance to mess with some of the globals,
# now make them read-only.
declare -r \
    N7_EOT \
    N7_SUDO \
    N7_TASK_TIMEOUT \
    N7_DEFAULT_TASK_TYPE \
    N7_SSH_OPTS \
    N7_SSH_CMD 

N7::load_tasks

# Run N7 built-in tasks first
N7::run_tasks_on_hosts "${N7_BUILTIN_TASKS[*]}" "${N7_HOSTS[*]}" >>"$N7_INTERNAL_ERR_FILE" 2>&1 ||
    N7::die "Failed initializing remote hosts!"

# Unset the built-in tasks and prevent them from showing up in n7 outputs.
N7::scope_do() {
    local i host length=${#N7_BUILTIN_TASKS[*]}
    for ((i=0; i < length; i++)); do
        unset N7_TASK_OPTS_$i
        unset N7_TASKS[$i]
        #Note: However, the above won't affect the indexes of user-defined tasks.
    done
    unset -f ${N7_BUILTIN_TASKS[*]}
    for host in ${N7_HOSTS[*]}; do
        : > "$(N7::ssh_out_file $host)"
        : > "$(N7::ssh_err_file $host)"
        # ssh doesn't know that we just truncated the files. This results in
        # null bytes at the beginning of the files. So, we write an EOT line,
        # with task index == the index of the last built-in task run, to make
        # the output of task 0 starts on a newline, and to avoid the null bytes
        # from appearing as the first user task's output.
	N7::send_eot_line $host 0
    done
}; N7::scope_do; unset -f N7::scope_do
declare -r N7_TASKS

# Run user's N7 tasks
N7::log "Run id=$N7_RUN_ID -- N7_DIR=$(N7::q "$N7_DIR") N7_EOT=$N7_EOT"
N7::run_tasks_on_hosts "${N7_TASKS[*]}" "${N7_HOSTS[*]}"

